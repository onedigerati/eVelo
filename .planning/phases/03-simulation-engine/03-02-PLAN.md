---
phase: 03-simulation-engine
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/simulation/bootstrap.ts
autonomous: true

must_haves:
  truths:
    - "Simple bootstrap samples with replacement from historical returns"
    - "Block bootstrap preserves autocorrelation structure"
    - "Automatic block length selection via Politis-White rule"
    - "Both methods accept seeded RNG for reproducibility"
  artifacts:
    - path: "src/simulation/bootstrap.ts"
      provides: "simpleBootstrap, blockBootstrap, optimalBlockLength functions"
      exports: ["simpleBootstrap", "blockBootstrap", "optimalBlockLength"]
      min_lines: 80
  key_links:
    - from: "blockBootstrap"
      to: "optimalBlockLength"
      via: "function call when blockSize not provided"
      pattern: "optimalBlockLength\\("
---

<objective>
Implement simple and block bootstrap resampling for historical returns.

Purpose: Provide the two bootstrap methods for Monte Carlo return generation (SIM-04, SIM-05).
Output: Bootstrap module with simple resampling and autocorrelation-preserving block bootstrap.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-simulation-engine/03-RESEARCH.md

@src/simulation/types.ts
@src/math/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement simple bootstrap resampling</name>
  <files>src/simulation/bootstrap.ts</files>
  <action>
    Create src/simulation/bootstrap.ts with simpleBootstrap function:

    ```typescript
    import { mean } from '../math';

    /**
     * Simple bootstrap resampling with replacement
     *
     * Samples randomly from historical returns without preserving
     * any time-series structure. Suitable when autocorrelation is negligible.
     *
     * @param returns Historical return series
     * @param targetLength Number of returns to generate
     * @param rng Random number generator (0-1)
     * @returns Array of resampled returns
     */
    export function simpleBootstrap(
      returns: number[],
      targetLength: number,
      rng: () => number
    ): number[] {
      if (returns.length === 0) {
        throw new Error('Cannot bootstrap from empty returns array');
      }

      const result: number[] = [];
      const n = returns.length;

      for (let i = 0; i < targetLength; i++) {
        const idx = Math.floor(rng() * n);
        result.push(returns[idx]);
      }

      return result;
    }
    ```

    Key implementation details:
    - Accept custom RNG for reproducibility (seeded externally)
    - Throw on empty input (defensive)
    - Use Math.floor for index calculation (not round)
  </action>
  <verify>Function compiles without errors</verify>
  <done>simpleBootstrap function implemented with seeded RNG support</done>
</task>

<task type="auto">
  <name>Task 2: Implement Politis-White automatic block length</name>
  <files>src/simulation/bootstrap.ts</files>
  <action>
    Add optimalBlockLength function to bootstrap.ts:

    ```typescript
    /**
     * Politis-White (2004) automatic block length selection
     *
     * Calculates optimal block length for block bootstrap based on
     * first-order autocorrelation of the series. Higher autocorrelation
     * results in larger blocks to preserve serial dependence.
     *
     * Reference: Politis & White, "Automatic Block-Length Selection for
     * the Dependent Bootstrap", Econometric Reviews 23(1), 2004
     *
     * @param returns Time series of returns
     * @returns Optimal block length (clamped to [3, n/4])
     */
    export function optimalBlockLength(returns: number[]): number {
      const n = returns.length;

      if (n < 12) {
        // Too short for meaningful autocorrelation estimate
        return Math.max(3, Math.floor(n / 2));
      }

      // Calculate sample mean
      const meanR = mean(returns);

      // Calculate first-order autocorrelation (lag-1)
      let numerator = 0;
      let denominator = 0;

      for (let i = 1; i < n; i++) {
        numerator += (returns[i] - meanR) * (returns[i - 1] - meanR);
      }
      for (let i = 0; i < n; i++) {
        denominator += (returns[i] - meanR) ** 2;
      }

      // Avoid division by zero
      if (denominator === 0) {
        return 3;
      }

      const rho1 = numerator / denominator;

      // Politis-White rule with Patton-Politis-White correction
      // g captures persistence: higher autocorrelation -> larger g
      const absRho = Math.abs(rho1);
      const rhoSquared = rho1 ** 2;

      // Guard against rho1 = 1 (perfect autocorrelation)
      if (rhoSquared >= 1) {
        return Math.floor(n / 4);
      }

      const g = (2 * absRho) / (1 - rhoSquared);

      // Block length formula: L* = c * n^(1/3) * g^(1/3)
      // Using c â‰ˆ (3/2)^(1/3) from the literature
      const blockLength = Math.ceil(
        Math.pow((3 * n) / 2, 1 / 3) * Math.pow(Math.max(g, 0.01), 1 / 3)
      );

      // Clamp to reasonable bounds: minimum 3, maximum n/4
      return Math.max(3, Math.min(Math.floor(n / 4), blockLength));
    }
    ```

    Key implementation details:
    - Handle short series gracefully (n < 12)
    - Guard against zero variance and perfect autocorrelation
    - Clamp output to [3, n/4] range
    - Use small minimum for g to avoid zero block length
  </action>
  <verify>Function handles edge cases (short series, zero variance)</verify>
  <done>optimalBlockLength implements Politis-White rule with guards</done>
</task>

<task type="auto">
  <name>Task 3: Implement moving block bootstrap</name>
  <files>src/simulation/bootstrap.ts</files>
  <action>
    Add blockBootstrap function to bootstrap.ts:

    ```typescript
    /**
     * Moving block bootstrap resampling
     *
     * Preserves autocorrelation by sampling contiguous blocks from
     * the historical series. Blocks can overlap in the original series.
     *
     * Use for return series with significant serial correlation
     * (e.g., monthly returns, high-frequency data).
     *
     * @param returns Historical return series
     * @param targetLength Number of returns to generate
     * @param rng Random number generator (0-1)
     * @param blockSize Optional fixed block size (auto-calculated if not provided)
     * @returns Array of resampled returns preserving autocorrelation
     */
    export function blockBootstrap(
      returns: number[],
      targetLength: number,
      rng: () => number,
      blockSize?: number
    ): number[] {
      if (returns.length === 0) {
        throw new Error('Cannot bootstrap from empty returns array');
      }

      const n = returns.length;

      // Calculate or validate block size
      const effectiveBlockSize = blockSize ?? optimalBlockLength(returns);

      // Block size cannot exceed series length
      const safeBlockSize = Math.min(effectiveBlockSize, n);

      if (safeBlockSize < 1) {
        throw new Error('Block size must be at least 1');
      }

      const result: number[] = [];

      // Maximum starting index for a block
      const maxStart = n - safeBlockSize;

      while (result.length < targetLength) {
        // Select random block starting position
        const startIdx = maxStart > 0 ? Math.floor(rng() * (maxStart + 1)) : 0;

        // Copy block to result (up to targetLength)
        for (let i = 0; i < safeBlockSize && result.length < targetLength; i++) {
          result.push(returns[startIdx + i]);
        }
      }

      return result;
    }
    ```

    Key implementation details:
    - Auto-calculate block size if not provided
    - Handle edge case where blockSize > n
    - Sample overlapping blocks (moving block bootstrap)
    - Stop exactly at targetLength (don't overshoot)
  </action>
  <verify>Block bootstrap preserves local structure in resampled series</verify>
  <done>blockBootstrap implemented with auto block length and seeded RNG</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] All three functions exported from bootstrap.ts
- [ ] simpleBootstrap produces correct length output
- [ ] blockBootstrap auto-calculates block size when not provided
- [ ] optimalBlockLength returns values in [3, n/4] range
</verification>

<success_criteria>

- All tasks completed
- SIM-04 (simple bootstrap) implemented
- SIM-05 (block bootstrap) implemented
- Both methods accept seeded RNG for reproducibility
- Auto block length selection via Politis-White rule
</success_criteria>

<output>
After completion, create `.planning/phases/03-simulation-engine/03-02-SUMMARY.md`
</output>
