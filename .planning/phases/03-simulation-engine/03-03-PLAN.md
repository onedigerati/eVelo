---
phase: 03-simulation-engine
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/simulation/regime-switching.ts
autonomous: true

must_haves:
  truths:
    - "Regime transitions follow Markov chain with configurable matrix"
    - "Each regime generates returns from its own distribution"
    - "Bull/bear/crash regimes have distinct mean and volatility"
    - "Regime sequence is reproducible with seeded RNG"
  artifacts:
    - path: "src/simulation/regime-switching.ts"
      provides: "nextRegime, generateRegimeReturns functions"
      exports: ["nextRegime", "generateRegimeReturns"]
      min_lines: 60
  key_links:
    - from: "generateRegimeReturns"
      to: "normalRandom"
      via: "import from math module"
      pattern: "normalRandom\\("
---

<objective>
Implement regime-switching return generation with Markov transitions.

Purpose: Model realistic bull/bear/crash market sequences (SIM-06).
Output: Regime-switching module generating returns based on market state transitions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-simulation-engine/03-RESEARCH.md

@src/simulation/types.ts
@src/math/distributions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement regime transition function</name>
  <files>src/simulation/regime-switching.ts</files>
  <action>
    Create src/simulation/regime-switching.ts with nextRegime function:

    ```typescript
    import type { MarketRegime, TransitionMatrix } from './types';

    /**
     * Determine next market regime via Markov transition
     *
     * Uses the current regime's row in the transition matrix to
     * probabilistically select the next regime.
     *
     * @param current Current market regime
     * @param matrix Transition probability matrix
     * @param rng Random number generator (0-1)
     * @returns Next market regime
     */
    export function nextRegime(
      current: MarketRegime,
      matrix: TransitionMatrix,
      rng: () => number
    ): MarketRegime {
      const probs = matrix[current];
      const r = rng();

      // Cumulative probability selection
      if (r < probs.bull) {
        return 'bull';
      }
      if (r < probs.bull + probs.bear) {
        return 'bear';
      }
      return 'crash';
    }
    ```

    Key implementation details:
    - Uses cumulative probability for regime selection
    - Accepts custom RNG for reproducibility
    - Returns MarketRegime type for type safety
  </action>
  <verify>Function compiles and type-checks correctly</verify>
  <done>nextRegime function implements Markov transition logic</done>
</task>

<task type="auto">
  <name>Task 2: Implement regime-based return generation</name>
  <files>src/simulation/regime-switching.ts</files>
  <action>
    Add generateRegimeReturns function to regime-switching.ts:

    ```typescript
    import { normalRandom } from '../math';
    import type {
      MarketRegime,
      TransitionMatrix,
      RegimeParams,
      DEFAULT_TRANSITION_MATRIX,
      DEFAULT_REGIME_PARAMS
    } from './types';

    /**
     * Regime parameters for each market state
     */
    export type RegimeParamsMap = Record<MarketRegime, RegimeParams>;

    /**
     * Result of regime-switching return generation
     */
    export interface RegimeReturnsResult {
      /** Generated annual returns */
      returns: number[];
      /** Regime for each year (for analysis/debugging) */
      regimes: MarketRegime[];
    }

    /**
     * Generate returns using regime-switching model
     *
     * Simulates a Markov chain of market regimes (bull/bear/crash)
     * and generates returns from each regime's distribution.
     * This captures realistic volatility clustering and crash sequences.
     *
     * Based on Hamilton (1989) regime-switching model.
     *
     * @param years Number of years to generate
     * @param initialRegime Starting market regime (default: 'bull')
     * @param matrix Transition probability matrix
     * @param params Return distribution parameters per regime
     * @param rng Random number generator (0-1)
     * @returns Object with returns array and regime sequence
     */
    export function generateRegimeReturns(
      years: number,
      rng: () => number,
      initialRegime: MarketRegime = 'bull',
      matrix?: TransitionMatrix,
      params?: RegimeParamsMap
    ): RegimeReturnsResult {
      // Import defaults from types if not provided
      const effectiveMatrix = matrix ?? DEFAULT_TRANSITION_MATRIX;
      const effectiveParams = params ?? DEFAULT_REGIME_PARAMS;

      const returns: number[] = [];
      const regimes: MarketRegime[] = [];
      let currentRegime = initialRegime;

      for (let year = 0; year < years; year++) {
        // Record current regime
        regimes.push(currentRegime);

        // Generate return from current regime's distribution
        const { mean, stddev } = effectiveParams[currentRegime];
        const yearReturn = normalRandom(mean, stddev, rng);
        returns.push(yearReturn);

        // Transition to next regime
        currentRegime = nextRegime(currentRegime, effectiveMatrix, rng);
      }

      return { returns, regimes };
    }
    ```

    Key implementation details:
    - Uses normalRandom from math module (Box-Muller)
    - Returns both returns and regime sequence (useful for visualization)
    - Accepts optional custom transition matrix and regime params
    - Default to 'bull' initial regime (typical starting assumption)
  </action>
  <verify>Function generates returns with correct length and regime tracking</verify>
  <done>generateRegimeReturns produces regime-aware return series</done>
</task>

<task type="auto">
  <name>Task 3: Add helper for multi-asset regime returns</name>
  <files>src/simulation/regime-switching.ts</files>
  <action>
    Add generateCorrelatedRegimeReturns function:

    ```typescript
    import { correlatedSamples } from '../math';

    /**
     * Generate correlated returns across multiple assets using regime model
     *
     * All assets share the same regime sequence but returns are
     * correlated according to the provided correlation matrix.
     *
     * @param years Number of years to generate
     * @param numAssets Number of assets in portfolio
     * @param correlationMatrix Asset correlation matrix (from historical data)
     * @param rng Random number generator
     * @param initialRegime Starting regime
     * @param matrix Transition matrix
     * @param params Regime parameters (applied to all assets)
     * @returns Object with 2D returns array [asset][year] and regime sequence
     */
    export function generateCorrelatedRegimeReturns(
      years: number,
      numAssets: number,
      correlationMatrix: number[][],
      rng: () => number,
      initialRegime: MarketRegime = 'bull',
      matrix?: TransitionMatrix,
      params?: RegimeParamsMap
    ): { returns: number[][]; regimes: MarketRegime[] } {
      const effectiveMatrix = matrix ?? DEFAULT_TRANSITION_MATRIX;
      const effectiveParams = params ?? DEFAULT_REGIME_PARAMS;

      // Generate regime sequence first
      const regimes: MarketRegime[] = [];
      let currentRegime = initialRegime;

      for (let year = 0; year < years; year++) {
        regimes.push(currentRegime);
        currentRegime = nextRegime(currentRegime, effectiveMatrix, rng);
      }

      // Initialize returns arrays for each asset
      const returns: number[][] = Array.from(
        { length: numAssets },
        () => new Array(years)
      );

      // Generate correlated returns for each year
      for (let year = 0; year < years; year++) {
        const regime = regimes[year];
        const { mean, stddev } = effectiveParams[regime];

        // Generate correlated samples with regime-appropriate mean/stddev
        const yearReturns = correlatedSamples(
          numAssets,
          correlationMatrix,
          rng,
          mean,
          stddev
        );

        // Assign to each asset
        for (let asset = 0; asset < numAssets; asset++) {
          returns[asset][year] = yearReturns[asset];
        }
      }

      return { returns, regimes };
    }
    ```

    Key implementation details:
    - All assets share same regime sequence (realistic - markets move together)
    - Uses correlatedSamples from math module for proper correlation
    - Returns structured for easy portfolio value calculation
    - Regime params apply uniformly (can extend for per-asset params later)
  </action>
  <verify>Multi-asset returns have correct dimensions and correlation structure</verify>
  <done>Correlated regime returns support multi-asset portfolios</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] nextRegime produces valid MarketRegime values
- [ ] generateRegimeReturns produces correct length arrays
- [ ] generateCorrelatedRegimeReturns produces [numAssets][years] shaped output
- [ ] All functions accept seeded RNG for reproducibility
</verification>

<success_criteria>

- All tasks completed
- SIM-06 (regime-switching) implemented
- Markov transitions use configurable matrix
- Each regime has distinct return distribution
- Multi-asset variant preserves correlation structure
</success_criteria>

<output>
After completion, create `.planning/phases/03-simulation-engine/03-03-SUMMARY.md`
</output>
