---
phase: 03-simulation-engine
plan: 04
type: execute
wave: 3
depends_on: ["03-02", "03-03"]
files_modified:
  - src/simulation/monte-carlo.ts
  - src/simulation/simulation.worker.ts
  - src/simulation/index.ts
autonomous: true

must_haves:
  truths:
    - "User can run 1,000 to 100,000 iterations without browser freeze"
    - "User can see progress updates during simulation"
    - "User can cancel in-progress simulation"
    - "Simulation results transfer efficiently to main thread"
    - "Portfolio value calculated correctly over time horizon"
  artifacts:
    - path: "src/simulation/monte-carlo.ts"
      provides: "runMonteCarlo core simulation function"
      exports: ["runMonteCarlo"]
      min_lines: 100
    - path: "src/simulation/simulation.worker.ts"
      provides: "Web Worker entry point with Comlink"
      exports: ["simulate"]
      min_lines: 40
    - path: "src/simulation/index.ts"
      provides: "Main thread API with progress and cancel"
      exports: ["runSimulation", "cancelSimulation"]
      min_lines: 50
  key_links:
    - from: "src/simulation/index.ts"
      to: "src/simulation/simulation.worker.ts"
      via: "ComlinkWorker instantiation"
      pattern: "ComlinkWorker"
    - from: "simulation.worker.ts"
      to: "monte-carlo.ts"
      via: "runMonteCarlo call"
      pattern: "runMonteCarlo\\("
---

<objective>
Create Monte Carlo simulation core with Web Worker and main thread API.

Purpose: Complete the simulation engine with non-blocking execution, progress reporting, and cancellation (SIM-01, SIM-02, SIM-03, SIM-08).
Output: Full simulation stack from main thread API to worker execution.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-simulation-engine/03-RESEARCH.md

# Reference prior summaries for types and bootstrap/regime modules
@.planning/phases/03-simulation-engine/03-01-SUMMARY.md
@.planning/phases/03-simulation-engine/03-02-SUMMARY.md
@.planning/phases/03-simulation-engine/03-03-SUMMARY.md

@src/simulation/types.ts
@src/simulation/bootstrap.ts
@src/simulation/regime-switching.ts
@src/math/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Monte Carlo core simulation</name>
  <files>src/simulation/monte-carlo.ts</files>
  <action>
    Create src/simulation/monte-carlo.ts with the core simulation loop:

    ```typescript
    import seedrandom from 'seedrandom';
    import { sum, mean, stddev, percentile, correlatedSamples } from '../math';
    import { simpleBootstrap, blockBootstrap } from './bootstrap';
    import { generateRegimeReturns, generateCorrelatedRegimeReturns } from './regime-switching';
    import type {
      SimulationConfig,
      PortfolioConfig,
      SimulationOutput,
      YearlyPercentiles,
      SimulationStatistics,
    } from './types';

    /** Batch size for progress reporting */
    const BATCH_SIZE = 1000;

    /** Default inflation rate (3%) */
    const DEFAULT_INFLATION_RATE = 0.03;

    /**
     * Run Monte Carlo simulation
     *
     * Executes configurable iterations of portfolio growth simulation,
     * using bootstrap or regime-switching return generation.
     *
     * @param config Simulation configuration
     * @param portfolio Portfolio with assets and correlations
     * @param onProgress Optional progress callback (percent: 0-100)
     * @param signal Optional AbortSignal for cancellation
     * @returns Simulation output with terminal values and statistics
     */
    export async function runMonteCarlo(
      config: SimulationConfig,
      portfolio: PortfolioConfig,
      onProgress?: (percent: number) => void,
      signal?: AbortSignal
    ): Promise<SimulationOutput> {
      const {
        iterations,
        timeHorizon,
        initialValue,
        inflationAdjusted,
        inflationRate = DEFAULT_INFLATION_RATE,
        resamplingMethod,
        blockSize,
        seed,
      } = config;

      // Create seeded RNG for reproducibility
      const rng = seedrandom(seed ?? Date.now().toString());

      // Terminal values array (transferred back to main thread)
      const terminalValues = new Float64Array(iterations);

      // Track yearly values for percentile calculation
      // Structure: yearlyValues[year][iteration]
      const yearlyValues: number[][] = Array.from(
        { length: timeHorizon },
        () => new Array(iterations)
      );

      const numAssets = portfolio.assets.length;
      const weights = portfolio.assets.map(a => a.weight);

      // Run iterations in batches
      for (let batch = 0; batch < iterations; batch += BATCH_SIZE) {
        // Check for cancellation
        if (signal?.aborted) {
          throw new DOMException('Simulation cancelled', 'AbortError');
        }

        const batchEnd = Math.min(batch + BATCH_SIZE, iterations);

        for (let i = batch; i < batchEnd; i++) {
          // Generate returns for this iteration
          const assetReturns = generateIterationReturns(
            resamplingMethod,
            timeHorizon,
            portfolio,
            rng,
            blockSize
          );

          // Simulate portfolio growth
          let portfolioValue = initialValue;

          for (let year = 0; year < timeHorizon; year++) {
            // Calculate weighted portfolio return
            let portfolioReturn = 0;
            for (let a = 0; a < numAssets; a++) {
              portfolioReturn += weights[a] * assetReturns[a][year];
            }

            // Apply return to portfolio value
            portfolioValue *= (1 + portfolioReturn);

            // Apply inflation adjustment if enabled
            if (inflationAdjusted) {
              portfolioValue /= (1 + inflationRate);
            }

            // Store yearly value
            yearlyValues[year][i] = portfolioValue;
          }

          // Store terminal value
          terminalValues[i] = portfolioValue;
        }

        // Report progress
        if (onProgress) {
          onProgress((batchEnd / iterations) * 100);
        }

        // Yield to event loop between batches
        await new Promise(resolve => setTimeout(resolve, 0));
      }

      // Calculate statistics
      const terminalArray = Array.from(terminalValues);
      const statistics = calculateStatistics(terminalArray, initialValue);
      const yearlyPercentiles = calculateYearlyPercentiles(yearlyValues);

      return {
        terminalValues,
        yearlyPercentiles,
        statistics,
      };
    }

    /**
     * Generate returns for one simulation iteration
     */
    function generateIterationReturns(
      method: SimulationConfig['resamplingMethod'],
      years: number,
      portfolio: PortfolioConfig,
      rng: () => number,
      blockSize?: number
    ): number[][] {
      const numAssets = portfolio.assets.length;

      if (method === 'regime') {
        // Use regime-switching with correlation
        const { returns } = generateCorrelatedRegimeReturns(
          years,
          numAssets,
          portfolio.correlationMatrix,
          rng
        );
        return returns;
      }

      // Bootstrap methods - sample each asset's historical returns
      const returns: number[][] = [];

      for (const asset of portfolio.assets) {
        const historical = asset.historicalReturns;

        if (method === 'block') {
          returns.push(blockBootstrap(historical, years, rng, blockSize));
        } else {
          // 'simple' bootstrap
          returns.push(simpleBootstrap(historical, years, rng));
        }
      }

      // Apply correlation for bootstrap methods
      // Note: For bootstrap, we resample actual historical data which already
      // embeds historical correlation. For more precise correlation control,
      // would need to decorrelate/recorrelate. Keeping simple for now.

      return returns;
    }

    /**
     * Calculate summary statistics from terminal values
     */
    function calculateStatistics(
      values: number[],
      initialValue: number
    ): SimulationStatistics {
      const successCount = values.filter(v => v >= initialValue).length;

      return {
        mean: mean(values),
        median: percentile(values, 0.5),
        stddev: stddev(values),
        successRate: (successCount / values.length) * 100,
      };
    }

    /**
     * Calculate percentiles for each year
     */
    function calculateYearlyPercentiles(
      yearlyValues: number[][]
    ): YearlyPercentiles[] {
      return yearlyValues.map((values, year) => ({
        year: year + 1,
        p10: percentile(values, 0.1),
        p25: percentile(values, 0.25),
        p50: percentile(values, 0.5),
        p75: percentile(values, 0.75),
        p90: percentile(values, 0.9),
      }));
    }
    ```

    Key implementation details:
    - Batch processing with BATCH_SIZE = 1000
    - Check AbortSignal for cancellation support
    - Yield to event loop between batches (prevents worker lockup)
    - Use seeded RNG for reproducibility
    - Calculate statistics in worker (avoid transferring full yearly arrays)
  </action>
  <verify>Function compiles and handles all three resampling methods</verify>
  <done>Monte Carlo core implements iteration batching with progress and cancellation</done>
</task>

<task type="auto">
  <name>Task 2: Create Web Worker with Comlink</name>
  <files>src/simulation/simulation.worker.ts</files>
  <action>
    Create src/simulation/simulation.worker.ts as the worker entry point:

    ```typescript
    import * as Comlink from 'comlink';
    import { runMonteCarlo } from './monte-carlo';
    import type { SimulationConfig, PortfolioConfig, SimulationOutput } from './types';

    /**
     * Simulation worker exposed functions
     *
     * This file is loaded in a Web Worker context via vite-plugin-comlink.
     * All exported functions become async on the main thread.
     */

    /** Current abort controller for cancellation */
    let currentAbortController: AbortController | null = null;

    /**
     * Run Monte Carlo simulation in worker
     *
     * @param config Simulation parameters
     * @param portfolio Portfolio configuration
     * @param onProgress Progress callback (wrapped by Comlink.proxy on main thread)
     * @returns Simulation results with transferable Float64Array
     */
    export async function simulate(
      config: SimulationConfig,
      portfolio: PortfolioConfig,
      onProgress?: (percent: number) => void
    ): Promise<SimulationOutput> {
      // Create abort controller for this simulation
      currentAbortController = new AbortController();

      try {
        const result = await runMonteCarlo(
          config,
          portfolio,
          onProgress,
          currentAbortController.signal
        );

        // Transfer the Float64Array buffer for zero-copy performance
        return Comlink.transfer(result, [result.terminalValues.buffer]);
      } finally {
        currentAbortController = null;
      }
    }

    /**
     * Cancel in-progress simulation
     */
    export function cancel(): void {
      if (currentAbortController) {
        currentAbortController.abort();
      }
    }

    /**
     * Health check for worker readiness
     */
    export function healthCheck(): string {
      return 'Worker ready';
    }
    ```

    Key implementation details:
    - Use Comlink.transfer() for zero-copy Float64Array transfer
    - Expose cancel() function for AbortController triggering
    - Health check for verifying worker is ready
    - No explicit Comlink.expose() needed with vite-plugin-comlink
  </action>
  <verify>Worker file compiles and exports expected functions</verify>
  <done>Worker entry point created with Comlink transfer and cancellation</done>
</task>

<task type="auto">
  <name>Task 3: Create main thread API</name>
  <files>src/simulation/index.ts</files>
  <action>
    Update src/simulation/index.ts to provide main thread API:

    ```typescript
    /**
     * Simulation module
     *
     * Provides Monte Carlo simulation with Web Worker support:
     * - Non-blocking execution via Web Worker
     * - Progress reporting during simulation
     * - Cancellation support
     * - Zero-copy result transfer
     */

    import * as Comlink from 'comlink';
    import type { SimulationConfig, PortfolioConfig, SimulationOutput } from './types';

    // Re-export all types
    export * from './types';

    // Re-export bootstrap and regime functions for direct use if needed
    export { simpleBootstrap, blockBootstrap, optimalBlockLength } from './bootstrap';
    export {
      nextRegime,
      generateRegimeReturns,
      generateCorrelatedRegimeReturns
    } from './regime-switching';

    /**
     * Lazy-initialized worker instance
     * Created on first simulation call
     */
    let worker: Comlink.Remote<typeof import('./simulation.worker')> | null = null;

    /**
     * Get or create the simulation worker
     */
    function getWorker(): Comlink.Remote<typeof import('./simulation.worker')> {
      if (!worker) {
        // @ts-expect-error ComlinkWorker is globally available via vite-plugin-comlink
        worker = new ComlinkWorker<typeof import('./simulation.worker')>(
          new URL('./simulation.worker', import.meta.url),
          { type: 'module' }
        );
      }
      return worker;
    }

    /**
     * Run Monte Carlo simulation
     *
     * Executes simulation in Web Worker to prevent UI blocking.
     * Progress updates are delivered via callback.
     *
     * @param config Simulation configuration
     * @param portfolio Portfolio with assets and correlations
     * @param onProgress Optional progress callback (0-100 percent)
     * @returns Promise resolving to simulation results
     * @throws DOMException with name 'AbortError' if cancelled
     *
     * @example
     * ```typescript
     * const result = await runSimulation(
     *   { iterations: 10000, timeHorizon: 30, ... },
     *   { assets: [...], correlationMatrix: [...] },
     *   (percent) => console.log(`${percent}% complete`)
     * );
     * console.log('Median terminal value:', result.statistics.median);
     * ```
     */
    export async function runSimulation(
      config: SimulationConfig,
      portfolio: PortfolioConfig,
      onProgress?: (percent: number) => void
    ): Promise<SimulationOutput> {
      const w = getWorker();

      // Verify worker is ready
      await w.healthCheck();

      // Wrap progress callback with Comlink.proxy for cross-thread calls
      const proxyProgress = onProgress ? Comlink.proxy(onProgress) : undefined;

      return w.simulate(config, portfolio, proxyProgress);
    }

    /**
     * Cancel in-progress simulation
     *
     * Signals the worker to abort the current simulation.
     * The runSimulation promise will reject with AbortError.
     */
    export function cancelSimulation(): void {
      const w = getWorker();
      w.cancel();
    }

    /**
     * Terminate the simulation worker
     *
     * Call when cleaning up or when worker is no longer needed.
     * Next simulation will create a fresh worker.
     */
    export function terminateWorker(): void {
      if (worker) {
        // Workers have terminate method, but Comlink remote doesn't expose it
        // Just null out the reference; browser will GC when no references remain
        worker = null;
      }
    }
    ```

    Key implementation details:
    - Lazy worker initialization (created on first use)
    - Comlink.proxy() wraps progress callback for cross-thread use
    - Export all submodules for direct access if needed
    - Health check before simulation ensures worker is ready
    - cancelSimulation() for abort support
    - @ts-expect-error for ComlinkWorker global (vite-plugin-comlink provides it)
  </action>
  <verify>Main thread API compiles and exports runSimulation, cancelSimulation</verify>
  <done>Main thread API provides complete simulation interface</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm run dev` starts and worker loads without errors
- [ ] runSimulation is importable from '@/simulation'
- [ ] All three resampling methods work (simple, block, regime)
- [ ] Progress callback receives updates during simulation
- [ ] cancelSimulation aborts in-progress simulation
</verification>

<success_criteria>

- All tasks completed
- SIM-01 (configurable iterations) implemented
- SIM-02 (multi-asset portfolio) handled via portfolio config
- SIM-03 (time horizon) configurable
- SIM-08 (inflation adjustment) implemented
- Web Worker prevents UI blocking
- Progress reporting works
- Cancellation works
</success_criteria>

<output>
After completion, create `.planning/phases/03-simulation-engine/03-04-SUMMARY.md`
</output>
