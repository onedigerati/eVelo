---
phase: 20-financial-calculation-audit
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/sbloc/validation.ts
  - src/sbloc/engine.ts
  - src/sbloc/index.ts
autonomous: true

must_haves:
  truths:
    - "SBLOC state validated after every mutation"
    - "LTV edge cases (Infinity, NaN) caught before propagating"
    - "Invalid states throw descriptive errors"
  artifacts:
    - path: "src/sbloc/validation.ts"
      provides: "State validation functions with error types"
      exports: ["validateSBLOCState", "SBLOCStateValidationError", "validateLTV"]
    - path: "src/sbloc/engine.ts"
      provides: "Updated engine with validation calls"
  key_links:
    - from: "src/sbloc/engine.ts"
      to: "src/sbloc/validation.ts"
      via: "import and call validateSBLOCState"
      pattern: "validateSBLOCState\\(newState"
---

<objective>
Add state validation guards to SBLOC engine

Purpose: Address Risk Area #12 (No State Validation in SBLOC) and Risk Area #11 (LTV Floating Point Edge Cases). Add validation functions that catch invalid states (negative values, NaN, Infinity) before they propagate through calculations and cause silent failures.

Output: New validation module and integration with SBLOC engine step function.
</objective>

<execution_context>
@C:\Users\ungac\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ungac\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/20-financial-calculation-audit/20-RESEARCH.md
@src/sbloc/engine.ts
@src/sbloc/types.ts
@src/sbloc/ltv.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SBLOC validation module</name>
  <files>src/sbloc/validation.ts</files>
  <action>
Create validation module with the following:

1. Custom error class:
```typescript
export class SBLOCStateValidationError extends Error {
  constructor(
    message: string,
    public readonly state: Partial<SBLOCState>,
    public readonly field: string
  ) {
    super(`SBLOC State Validation Failed: ${message}`);
    this.name = 'SBLOCStateValidationError';
  }
}
```

2. LTV validation function:
```typescript
/**
 * Validate LTV value for edge cases
 *
 * Edge case handling:
 * - portfolioValue = 0, loanBalance > 0: Return Infinity (acceptable, means margin call certain)
 * - portfolioValue = 0, loanBalance = 0: Return 0 (no position)
 * - NaN: Throw error (invalid state)
 *
 * @returns true if LTV is valid (including Infinity for total loss)
 * @throws SBLOCStateValidationError if LTV is NaN
 */
export function validateLTV(
  ltv: number,
  portfolioValue: number,
  loanBalance: number
): boolean {
  // NaN is never valid
  if (Number.isNaN(ltv)) {
    throw new SBLOCStateValidationError(
      'LTV is NaN',
      { currentLTV: ltv, portfolioValue, loanBalance },
      'currentLTV'
    );
  }

  // Infinity is valid when portfolio = 0 and loan > 0 (margin call certain)
  if (ltv === Infinity && portfolioValue === 0 && loanBalance > 0) {
    return true;
  }

  // Negative LTV is invalid
  if (ltv < 0) {
    throw new SBLOCStateValidationError(
      'LTV cannot be negative',
      { currentLTV: ltv, portfolioValue, loanBalance },
      'currentLTV'
    );
  }

  return true;
}
```

3. Full state validation function:
```typescript
/**
 * Validate complete SBLOC state
 *
 * Call after every state mutation to catch invalid states early.
 * Throws SBLOCStateValidationError if any field is invalid.
 */
export function validateSBLOCState(
  state: SBLOCState,
  config: SBLOCConfig
): void {
  // Portfolio value must be non-negative
  if (state.portfolioValue < 0) {
    throw new SBLOCStateValidationError(
      'Portfolio value cannot be negative',
      state,
      'portfolioValue'
    );
  }

  // Loan balance must be non-negative
  if (state.loanBalance < 0) {
    throw new SBLOCStateValidationError(
      'Loan balance cannot be negative',
      state,
      'loanBalance'
    );
  }

  // Validate LTV (handles NaN, allows Infinity for edge cases)
  validateLTV(state.currentLTV, state.portfolioValue, state.loanBalance);

  // Years since start must be non-negative integer
  if (state.yearsSinceStart < 0 || !Number.isInteger(state.yearsSinceStart)) {
    throw new SBLOCStateValidationError(
      'yearsSinceStart must be non-negative integer',
      state,
      'yearsSinceStart'
    );
  }
}
```

Add imports for SBLOCState and SBLOCConfig from ./types.
  </action>
  <verify>`npx tsc --noEmit` passes</verify>
  <done>Validation module with error class and validation functions created</done>
</task>

<task type="auto">
  <name>Task 2: Integrate validation into SBLOC engine</name>
  <files>src/sbloc/engine.ts</files>
  <action>
Update stepSBLOC function to call validation:

1. Add import at top:
```typescript
import { validateSBLOCState, SBLOCStateValidationError } from './validation';
```

2. Add validation call before returning result (after Step 7, before return):
```typescript
  // Step 8: Validate final state before returning
  // Catches NaN, Infinity (except valid edge cases), negative values
  try {
    validateSBLOCState(newState, config);
  } catch (error) {
    if (error instanceof SBLOCStateValidationError) {
      // Log for debugging but don't crash simulation
      console.warn('SBLOC state validation warning:', error.message, error.state);
      // Mark portfolio as failed if state is invalid
      portfolioFailed = true;
    } else {
      throw error;
    }
  }
```

3. Also add validation in initializeSBLOCState:
```typescript
export function initializeSBLOCState(
  config: SBLOCConfig,
  initialPortfolioValue: number,
  initialLoanBalance: number = 0
): SBLOCState {
  // ... existing code ...

  // Validate initial state
  try {
    validateSBLOCState(state, config);
  } catch (error) {
    if (error instanceof SBLOCStateValidationError) {
      console.warn('Initial SBLOC state validation warning:', error.message);
    }
    throw error; // Re-throw for initial state (shouldn't happen with valid inputs)
  }

  return state;
}
```

Use try-catch to log warnings but continue simulation (graceful degradation).
  </action>
  <verify>`npx tsc --noEmit` passes; dev server shows no errors</verify>
  <done>SBLOC engine validates state after each step</done>
</task>

<task type="auto">
  <name>Task 3: Update barrel export</name>
  <files>src/sbloc/index.ts</files>
  <action>
Add exports for validation module to barrel file:

```typescript
// Add to existing exports
export {
  validateSBLOCState,
  validateLTV,
  SBLOCStateValidationError,
} from './validation';
```

This makes validation utilities available for testing and external use.
  </action>
  <verify>`npx tsc --noEmit` passes</verify>
  <done>Validation exports added to SBLOC module barrel</done>
</task>

</tasks>

<verification>
1. Run `npx tsc --noEmit` - should pass
2. Verify validation.ts exports all 3 items
3. Test edge case in browser console:
   - Create state with portfolioValue = 0, loanBalance > 0
   - Verify LTV = Infinity is accepted (valid edge case)
4. Test invalid state:
   - State with NaN LTV should throw SBLOCStateValidationError
</verification>

<success_criteria>
- SBLOC state validated after every mutation
- Edge cases handled gracefully (Infinity allowed, NaN caught)
- Validation errors logged but don't crash simulation
- Types exported via barrel file
</success_criteria>

<output>
After completion, create `.planning/phases/20-financial-calculation-audit/20-02-SUMMARY.md`
</output>
