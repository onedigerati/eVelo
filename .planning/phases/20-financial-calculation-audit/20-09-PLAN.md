---
phase: 20-financial-calculation-audit
plan: 09
type: tdd
wave: 3
depends_on: ["20-01", "20-02", "20-03"]
files_modified:
  - vitest.config.ts
  - package.json
  - src/calculations/__tests__/sell-strategy.test.ts
  - src/sbloc/__tests__/validation.test.ts
autonomous: true

must_haves:
  truths:
    - "Vitest configured and running"
    - "Sell strategy success rate tests pass"
    - "SBLOC validation edge case tests pass"
  artifacts:
    - path: "vitest.config.ts"
      provides: "Vitest configuration for TypeScript"
    - path: "src/calculations/__tests__/sell-strategy.test.ts"
      provides: "Sell strategy unit tests"
    - path: "src/sbloc/__tests__/validation.test.ts"
      provides: "SBLOC validation unit tests"
  key_links:
    - from: "vitest.config.ts"
      to: "package.json"
      via: "test script"
      pattern: "vitest"
---

<objective>
Set up Vitest and add unit tests for key calculations

Purpose: Establish testing infrastructure and write unit tests for the most critical calculation fixes in this phase. Focus on sell strategy success rate and SBLOC validation edge cases.

Output: Vitest configured with passing tests for core calculations.
</objective>

<execution_context>
@C:\Users\ungac\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ungac\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/20-financial-calculation-audit/20-RESEARCH.md
@src/calculations/sell-strategy.ts
@src/sbloc/validation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install and configure Vitest</name>
  <files>vitest.config.ts, package.json</files>
  <action>
1. Install Vitest:
```bash
npm install --save-dev vitest @vitest/ui
```

2. Create vitest.config.ts:
```typescript
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    // Use TypeScript without compilation (vitest handles it)
    include: ['src/**/*.{test,spec}.{ts,tsx}'],
    exclude: ['node_modules', 'dist'],

    // Environment
    environment: 'node',

    // Coverage (optional, for future)
    // coverage: {
    //   provider: 'v8',
    //   reporter: ['text', 'html'],
    // },

    // Globals (optional)
    globals: false,
  },
});
```

3. Add test scripts to package.json:
```json
{
  "scripts": {
    "test": "vitest run",
    "test:watch": "vitest",
    "test:ui": "vitest --ui"
  }
}
```
  </action>
  <verify>`npm run test` runs (may have 0 tests initially)</verify>
  <done>Vitest configured and test command works</done>
</task>

<task type="auto">
  <name>Task 2: Write sell strategy success rate tests</name>
  <files>src/calculations/__tests__/sell-strategy.test.ts</files>
  <action>
Create test file for sell strategy:

```typescript
import { describe, test, expect } from 'vitest';
import { calculateSellStrategy } from '../sell-strategy';
import type { YearlyPercentiles } from '../../simulation/types';

// Helper to create mock percentile data
function createMockPercentiles(timeHorizon: number, growthRate: number): YearlyPercentiles[] {
  const percentiles: YearlyPercentiles[] = [];
  let value = 5000000; // $5M initial

  for (let year = 0; year <= timeHorizon; year++) {
    percentiles.push({
      year,
      p10: value * 0.8,
      p25: value * 0.9,
      p50: value,
      p75: value * 1.1,
      p90: value * 1.2,
    });
    value *= (1 + growthRate);
  }

  return percentiles;
}

describe('calculateSellStrategy', () => {
  describe('success rate definition', () => {
    test('success means terminal > initial (not just > 0)', () => {
      const config = {
        initialValue: 5000000,
        annualWithdrawal: 200000,
        withdrawalGrowth: 0.03,
        timeHorizon: 30,
      };

      // Create percentiles that result in modest growth
      const percentiles = createMockPercentiles(30, 0.05);
      const result = calculateSellStrategy(config, percentiles);

      // Success rate should be based on terminal > initial
      // With heavy withdrawals, success rate should be < 100%
      expect(result.successRate).toBeLessThan(100);
      expect(result.successRate).toBeGreaterThanOrEqual(0);
    });

    test('depletionProbability tracks scenarios that ran out of money', () => {
      const config = {
        initialValue: 5000000,
        annualWithdrawal: 500000, // Very high withdrawal
        withdrawalGrowth: 0.03,
        timeHorizon: 30,
      };

      const percentiles = createMockPercentiles(30, 0.03); // Low growth
      const result = calculateSellStrategy(config, percentiles);

      // With high withdrawals and low growth, should have depletion
      expect(result.depletionProbability).toBeGreaterThanOrEqual(0);
      expect(result.depletionProbability).toBeLessThanOrEqual(100);
    });

    test('success rate <= (100 - depletionProbability)', () => {
      // A depleted portfolio cannot be successful, so:
      // successRate <= (100 - depletionProbability)
      const config = {
        initialValue: 5000000,
        annualWithdrawal: 300000,
        withdrawalGrowth: 0.03,
        timeHorizon: 30,
      };

      const percentiles = createMockPercentiles(30, 0.05);
      const result = calculateSellStrategy(config, percentiles);

      // Success implies not depleted, so:
      // success count <= (total - depleted count)
      // successRate <= (100 - depletionProbability)
      expect(result.successRate).toBeLessThanOrEqual(100 - result.depletionProbability + 0.1);
    });
  });

  describe('config validation', () => {
    test('uses default cost basis ratio when not specified', () => {
      const config = {
        initialValue: 5000000,
        annualWithdrawal: 200000,
        withdrawalGrowth: 0.03,
        timeHorizon: 30,
        // costBasisRatio not specified - should use default 0.4
      };

      const percentiles = createMockPercentiles(30, 0.07);
      const result = calculateSellStrategy(config, percentiles);

      // Result should be valid (uses default)
      expect(result.terminalNetWorth).toBeGreaterThan(0);
      expect(result.lifetimeTaxes).toBeGreaterThan(0);
    });

    test('respects custom cost basis ratio', () => {
      const baseConfig = {
        initialValue: 5000000,
        annualWithdrawal: 200000,
        withdrawalGrowth: 0.03,
        timeHorizon: 30,
      };

      const percentiles = createMockPercentiles(30, 0.07);

      // Low basis = high gains = high taxes
      const lowBasis = calculateSellStrategy(
        { ...baseConfig, costBasisRatio: 0.2 },
        percentiles
      );

      // High basis = low gains = low taxes
      const highBasis = calculateSellStrategy(
        { ...baseConfig, costBasisRatio: 0.8 },
        percentiles
      );

      // Low basis should result in higher lifetime taxes
      expect(lowBasis.lifetimeTaxes).toBeGreaterThan(highBasis.lifetimeTaxes);
    });
  });
});
```
  </action>
  <verify>`npm run test` shows sell-strategy tests passing</verify>
  <done>Sell strategy unit tests written and passing</done>
</task>

<task type="auto">
  <name>Task 3: Write SBLOC validation edge case tests</name>
  <files>src/sbloc/__tests__/validation.test.ts</files>
  <action>
Create test file for SBLOC validation:

```typescript
import { describe, test, expect } from 'vitest';
import {
  validateSBLOCState,
  validateLTV,
  SBLOCStateValidationError,
} from '../validation';
import type { SBLOCConfig, SBLOCState } from '../types';

const defaultConfig: SBLOCConfig = {
  annualInterestRate: 0.074,
  maxLTV: 0.65,
  maintenanceMargin: 0.50,
  liquidationHaircut: 0.05,
  annualWithdrawal: 50000,
  compoundingFrequency: 'annual',
  startYear: 0,
};

describe('validateLTV', () => {
  test('accepts valid LTV values', () => {
    expect(validateLTV(0.3, 1000000, 300000)).toBe(true);
    expect(validateLTV(0.5, 1000000, 500000)).toBe(true);
    expect(validateLTV(0, 1000000, 0)).toBe(true);
  });

  test('accepts Infinity when portfolio is 0 and loan > 0', () => {
    // This is a valid edge case - portfolio crashed but loan exists
    expect(validateLTV(Infinity, 0, 100000)).toBe(true);
  });

  test('throws on NaN LTV', () => {
    expect(() => validateLTV(NaN, 0, 0)).toThrow(SBLOCStateValidationError);
    expect(() => validateLTV(NaN, 1000, 500)).toThrow(SBLOCStateValidationError);
  });

  test('throws on negative LTV', () => {
    expect(() => validateLTV(-0.5, 1000000, 500000)).toThrow(SBLOCStateValidationError);
  });
});

describe('validateSBLOCState', () => {
  test('accepts valid state', () => {
    const state: SBLOCState = {
      portfolioValue: 1000000,
      loanBalance: 300000,
      currentLTV: 0.3,
      inWarningZone: false,
      yearsSinceStart: 5,
    };

    expect(() => validateSBLOCState(state, defaultConfig)).not.toThrow();
  });

  test('throws on negative portfolio value', () => {
    const state: SBLOCState = {
      portfolioValue: -100000,
      loanBalance: 300000,
      currentLTV: 0.3,
      inWarningZone: false,
      yearsSinceStart: 5,
    };

    expect(() => validateSBLOCState(state, defaultConfig)).toThrow(SBLOCStateValidationError);
  });

  test('throws on negative loan balance', () => {
    const state: SBLOCState = {
      portfolioValue: 1000000,
      loanBalance: -50000,
      currentLTV: 0.3,
      inWarningZone: false,
      yearsSinceStart: 5,
    };

    expect(() => validateSBLOCState(state, defaultConfig)).toThrow(SBLOCStateValidationError);
  });

  test('throws on fractional yearsSinceStart', () => {
    const state: SBLOCState = {
      portfolioValue: 1000000,
      loanBalance: 300000,
      currentLTV: 0.3,
      inWarningZone: false,
      yearsSinceStart: 5.5, // Invalid - should be integer
    };

    expect(() => validateSBLOCState(state, defaultConfig)).toThrow(SBLOCStateValidationError);
  });

  test('accepts zero portfolio with zero loan (no position)', () => {
    const state: SBLOCState = {
      portfolioValue: 0,
      loanBalance: 0,
      currentLTV: 0,
      inWarningZone: false,
      yearsSinceStart: 10,
    };

    expect(() => validateSBLOCState(state, defaultConfig)).not.toThrow();
  });

  test('accepts total loss scenario (portfolio=0, loan>0, LTV=Infinity)', () => {
    const state: SBLOCState = {
      portfolioValue: 0,
      loanBalance: 100000,
      currentLTV: Infinity,
      inWarningZone: true,
      yearsSinceStart: 10,
    };

    expect(() => validateSBLOCState(state, defaultConfig)).not.toThrow();
  });
});
```
  </action>
  <verify>`npm run test` shows validation tests passing</verify>
  <done>SBLOC validation edge case tests written and passing</done>
</task>

</tasks>

<verification>
1. Run `npm run test` - all tests should pass
2. Run `npm run test:watch` - should work for development
3. Verify test coverage of edge cases:
   - NaN LTV caught
   - Infinity LTV accepted for total loss
   - Negative values rejected
   - Success rate uses correct definition
</verification>

<success_criteria>
- Vitest installed and configured
- npm run test command works
- Sell strategy tests verify success rate definition
- SBLOC validation tests verify edge case handling
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/20-financial-calculation-audit/20-09-SUMMARY.md`
</output>
