---
phase: 18-fix-regime-switching
plan: 04
type: execute
wave: 3
depends_on: ["18-02", "18-03"]
files_modified:
  - src/simulation/monte-carlo.ts
  - src/simulation/regime-switching.ts
autonomous: true

must_haves:
  truths:
    - "Regime-switching mode uses asset-specific historical data for parameters"
    - "regimeCalibration config option affects simulation results"
    - "Historical mode produces different CAGR than Conservative mode"
  artifacts:
    - path: "src/simulation/monte-carlo.ts"
      provides: "Wiring of calibration to simulation"
      contains: "calibrateRegimeModelWithMode"
    - path: "src/simulation/regime-switching.ts"
      provides: "Support for asset-specific regime parameters"
      contains: "assetRegimeParams"
  key_links:
    - from: "src/simulation/monte-carlo.ts"
      to: "src/simulation/regime-calibration.ts"
      via: "calibration function call"
      pattern: "calibrateRegimeModelWithMode"
    - from: "src/simulation/monte-carlo.ts"
      to: "generateCorrelatedRegimeReturns"
      via: "passing calibrated params"
      pattern: "generateCorrelatedRegimeReturns.*params"
---

<objective>
Wire regimeCalibration to simulation engine, making regime-switching mode use asset-specific calibrated parameters instead of hardcoded defaults.

Purpose: Currently, the regimeCalibration setting is stored but never used - both "Historical" and "Conservative" modes produce identical results because generateCorrelatedRegimeReturns uses DEFAULT_REGIME_PARAMS for all assets. This plan connects the calibration system to the actual simulation.

Output: monte-carlo.ts and regime-switching.ts updated to derive and use asset-specific regime parameters based on the selected calibration mode.
</objective>

<execution_context>
@C:\Users\ungac\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ungac\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-fix-regime-switching/18-RESEARCH.md

# Source files
@src/simulation/monte-carlo.ts
@src/simulation/regime-switching.ts
@src/simulation/regime-calibration.ts
@src/simulation/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update generateCorrelatedRegimeReturns to support asset-specific parameters</name>
  <files>src/simulation/regime-switching.ts</files>
  <action>
Update `generateCorrelatedRegimeReturns` in `src/simulation/regime-switching.ts` to accept asset-specific regime parameters:

1. Add new optional parameter `assetRegimeParams: RegimeParamsMap[]` that provides per-asset regime parameters

2. Modify the return generation loop to use asset-specific parameters instead of shared params:

```typescript
/**
 * Generate correlated returns across multiple assets using regime model
 *
 * All assets share the same regime sequence but each asset can have
 * its own regime parameters (mean/stddev per regime).
 *
 * @param years Number of years to generate
 * @param numAssets Number of assets in portfolio
 * @param correlationMatrix Asset correlation matrix (from historical data)
 * @param rng Random number generator
 * @param initialRegime Starting regime
 * @param matrix Transition matrix
 * @param params Shared regime parameters (used if assetRegimeParams not provided)
 * @param assetRegimeParams Optional per-asset regime parameters
 * @returns Object with 2D returns array [asset][year] and regime sequence
 */
export function generateCorrelatedRegimeReturns(
  years: number,
  numAssets: number,
  correlationMatrix: number[][],
  rng: () => number,
  initialRegime: MarketRegime = 'bull',
  matrix?: TransitionMatrix,
  params?: RegimeParamsMap,
  assetRegimeParams?: RegimeParamsMap[]
): CorrelatedRegimeReturnsResult {
  const effectiveMatrix = matrix ?? DEFAULT_TRANSITION_MATRIX;
  const effectiveParams = params ?? DEFAULT_REGIME_PARAMS;

  // Generate regime sequence first
  const regimes: MarketRegime[] = [];
  let currentRegime = initialRegime;

  for (let year = 0; year < years; year++) {
    regimes.push(currentRegime);
    currentRegime = nextRegime(currentRegime, effectiveMatrix, rng);
  }

  // Initialize returns arrays for each asset
  const returns: number[][] = Array.from(
    { length: numAssets },
    () => new Array(years)
  );

  // Generate returns for each year
  for (let year = 0; year < years; year++) {
    const regime = regimes[year];

    if (assetRegimeParams && assetRegimeParams.length === numAssets) {
      // Asset-specific parameters: generate individual returns, then correlate
      // First generate uncorrelated returns for each asset
      const uncorrelated = assetRegimeParams.map(assetParams => {
        const { mean, stddev } = assetParams[regime];
        return normalRandom(mean, stddev, rng);
      });

      // Apply correlation using Cholesky decomposition
      // Note: For simplicity, we scale by target stddev after correlation
      // This is an approximation that preserves correlation structure
      const correlated = correlatedSamples(
        numAssets,
        correlationMatrix,
        rng,
        0, // mean=0 for correlation transform
        1  // stddev=1 for correlation transform
      );

      // Combine: use correlated structure but scale by asset-specific params
      for (let asset = 0; asset < numAssets; asset++) {
        const { mean, stddev } = assetRegimeParams[asset][regime];
        returns[asset][year] = mean + stddev * correlated[asset];
      }
    } else {
      // Shared parameters (original behavior)
      const { mean, stddev } = effectiveParams[regime];
      const yearReturns = correlatedSamples(
        numAssets,
        correlationMatrix,
        rng,
        mean,
        stddev
      );

      for (let asset = 0; asset < numAssets; asset++) {
        returns[asset][year] = yearReturns[asset];
      }
    }
  }

  return { returns, regimes };
}
```

Key changes:
- New `assetRegimeParams` parameter (array of RegimeParamsMap, one per asset)
- When provided, generates returns with asset-specific mean/stddev
- Preserves correlation structure via correlatedSamples
- Falls back to original behavior when not provided (backward compatible)
  </action>
  <verify>
1. `grep "assetRegimeParams" src/simulation/regime-switching.ts` shows parameter exists
2. `npx tsc --noEmit` passes
  </verify>
  <done>
- generateCorrelatedRegimeReturns accepts optional assetRegimeParams
- Asset-specific parameters produce asset-specific returns
- Correlation structure preserved
- Backward compatible (works without assetRegimeParams)
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire calibration to monte-carlo.ts</name>
  <files>src/simulation/monte-carlo.ts</files>
  <action>
Update `generateIterationReturns` in `src/simulation/monte-carlo.ts` to use calibration:

1. Import calibration functions:
```typescript
import {
  calibrateRegimeModelWithMode,
  calculatePortfolioRegimeParams,
} from './regime-calibration';
import type { RegimeCalibrationMode, RegimeParamsMap } from './types';
```

2. Update `generateIterationReturns` to accept and use calibration mode:

```typescript
/**
 * Generate returns for one simulation iteration
 */
function generateIterationReturns(
  method: SimulationConfig['resamplingMethod'],
  years: number,
  portfolio: PortfolioConfig,
  rng: () => number,
  blockSize?: number,
  regimeCalibration?: RegimeCalibrationMode,
  assetRegimeParams?: RegimeParamsMap[]
): number[][] {
  const numAssets = portfolio.assets.length;

  if (method === 'regime') {
    // Use regime-switching with correlation and calibrated params
    const { returns } = generateCorrelatedRegimeReturns(
      years,
      numAssets,
      portfolio.correlationMatrix,
      rng,
      'bull', // initialRegime
      undefined, // matrix (use default)
      undefined, // shared params (not used when assetRegimeParams provided)
      assetRegimeParams
    );
    return returns;
  }

  // Bootstrap methods - unchanged
  // ...existing bootstrap code...
}
```

3. In `runMonteCarlo`, calibrate regime parameters before iteration loop:

```typescript
// Near the top of runMonteCarlo, after extracting config values:

// Calibrate regime parameters if using regime method
let assetRegimeParams: RegimeParamsMap[] | undefined;

if (resamplingMethod === 'regime') {
  const calibrationMode = config.regimeCalibration ?? 'historical';

  // Calibrate each asset's regime parameters from its historical data
  assetRegimeParams = portfolio.assets.map(asset => {
    if (asset.historicalReturns.length >= 10) {
      return calibrateRegimeModelWithMode(asset.historicalReturns, calibrationMode);
    }
    // Fall back to default params if insufficient data
    return DEFAULT_REGIME_PARAMS;
  });
}

// Then pass assetRegimeParams to generateIterationReturns
const assetReturns = generateIterationReturns(
  resamplingMethod,
  timeHorizon,
  portfolio,
  rng,
  blockSize,
  config.regimeCalibration,
  assetRegimeParams
);
```

Also add import for DEFAULT_REGIME_PARAMS:
```typescript
import { DEFAULT_REGIME_PARAMS } from './types';
```

Key changes:
- Calibrate asset parameters once before iteration loop (not per-iteration)
- Use asset's historicalReturns for calibration
- Respect regimeCalibration mode setting
- Fall back to DEFAULT_REGIME_PARAMS if asset has <10 years of data
  </action>
  <verify>
1. `grep "calibrateRegimeModelWithMode" src/simulation/monte-carlo.ts` shows import and usage
2. `grep "assetRegimeParams" src/simulation/monte-carlo.ts` shows variable and usage
3. `npx tsc --noEmit` passes
4. `npm run build` succeeds
  </verify>
  <done>
- monte-carlo.ts imports and uses calibration functions
- Asset-specific regime parameters are calibrated from historical data
- regimeCalibration config option is respected
- Calibration happens once per simulation run (not per iteration)
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify end-to-end wiring works</name>
  <files>src/simulation/monte-carlo.ts</files>
  <action>
Add a console.log (temporary, for verification) at the point where calibration happens:

```typescript
if (resamplingMethod === 'regime') {
  const calibrationMode = config.regimeCalibration ?? 'historical';
  console.log(`Regime calibration mode: ${calibrationMode}`);

  assetRegimeParams = portfolio.assets.map((asset, idx) => {
    if (asset.historicalReturns.length >= 10) {
      const params = calibrateRegimeModelWithMode(asset.historicalReturns, calibrationMode);
      console.log(`Asset ${asset.id} regime params (${calibrationMode}):`, {
        bull: { mean: (params.bull.mean * 100).toFixed(1) + '%', stddev: (params.bull.stddev * 100).toFixed(1) + '%' },
        bear: { mean: (params.bear.mean * 100).toFixed(1) + '%', stddev: (params.bear.stddev * 100).toFixed(1) + '%' },
        crash: { mean: (params.crash.mean * 100).toFixed(1) + '%', stddev: (params.crash.stddev * 100).toFixed(1) + '%' },
      });
      return params;
    }
    console.log(`Asset ${asset.id}: Using default params (insufficient data)`);
    return DEFAULT_REGIME_PARAMS;
  });
}
```

This temporary logging allows verification that:
1. Calibration mode is being read correctly
2. Asset-specific params differ from DEFAULT_REGIME_PARAMS
3. Conservative mode produces different values than historical

After verification, remove or comment out the console.log statements (or leave them for debugging, wrapped in a debug flag check).
  </action>
  <verify>
1. `npm run build` succeeds
2. Run application in dev mode (`npm run dev`)
3. Run a simulation with regime-switching mode
4. Check browser console for calibration log output showing asset-specific parameters
5. Verify that parameters differ from default (12%/-8%/-30%)
6. Toggle between Historical and Conservative modes and verify different parameters
  </verify>
  <done>
- End-to-end wiring verified via console output
- Asset-specific parameters are being derived from historical data
- Historical and Conservative modes produce different parameters
- Simulation runs successfully with calibrated parameters
  </done>
</task>

</tasks>

<verification>
- `npm run build` completes without errors
- `npx tsc --noEmit` type checks pass
- Regime-switching simulations use asset-specific calibrated parameters
- regimeCalibration config option affects simulation results
- Historical mode uses actual historical data
- Conservative mode applies stress adjustments
</verification>

<success_criteria>
1. generateCorrelatedRegimeReturns accepts and uses assetRegimeParams
2. monte-carlo.ts calibrates regime parameters from asset historical data
3. regimeCalibration config option (historical/conservative) is respected
4. Asset parameters differ from DEFAULT_REGIME_PARAMS (12%/-8%/-30%)
5. Conservative mode produces lower returns and higher volatility than historical
6. Application builds and runs correctly
7. CAGR reflects actual portfolio characteristics when using regime-switching
</success_criteria>

<output>
After completion, create `.planning/phases/18-fix-regime-switching/18-04-SUMMARY.md`
</output>
