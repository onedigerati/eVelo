---
phase: 18-fix-regime-switching
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/simulation/regime-calibration.ts
  - src/simulation/index.ts
autonomous: true

must_haves:
  truths:
    - "Regime parameters can be derived from any asset's historical returns"
    - "Threshold-based classification correctly identifies bull/bear/crash returns"
    - "Derived parameters reflect actual asset characteristics"
  artifacts:
    - path: "src/simulation/regime-calibration.ts"
      provides: "Regime calibration functions"
      exports: ["classifyRegimes", "estimateRegimeParams", "calibrateRegimeModel"]
    - path: "src/simulation/index.ts"
      provides: "Barrel exports for calibration module"
      contains: "regime-calibration"
  key_links:
    - from: "src/simulation/regime-calibration.ts"
      to: "src/math/statistics.ts"
      via: "statistical calculations"
      pattern: "import.*from.*math"
---

<objective>
Create regime calibration module that derives bull/bear/crash parameters from historical returns using threshold-based classification.

Purpose: The current regime-switching model uses hardcoded S&P 500 parameters (12% bull, -8% bear, -30% crash) for ALL assets, ignoring actual historical data. This plan creates the calibration module that derives asset-specific regime parameters from historical return data.

Output: New `regime-calibration.ts` module with functions to classify historical returns into regimes and estimate mean/stddev parameters for each regime.
</objective>

<execution_context>
@C:\Users\ungac\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ungac\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-fix-regime-switching/18-RESEARCH.md

# Source files
@src/simulation/types.ts
@src/simulation/regime-switching.ts
@src/simulation/index.ts
@src/math/statistics.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create regime calibration module</name>
  <files>src/simulation/regime-calibration.ts</files>
  <action>
Create `src/simulation/regime-calibration.ts` with the following functions:

```typescript
/**
 * Regime Calibration Module
 *
 * Derives regime-switching parameters from historical return data
 * using threshold-based classification (not MLE/EM algorithm).
 *
 * Based on: Lunde & Timmermann (2004), Pagan & Sossounov (2003)
 */

import { mean, stddev, percentile } from '../math';
import type { RegimeParamsMap, MarketRegime } from './types';

/**
 * Classified returns by regime
 */
export interface ClassifiedReturns {
  bull: number[];
  bear: number[];
  crash: number[];
}

/**
 * Classify historical returns into bull/bear/crash regimes using percentile thresholds
 *
 * Classification thresholds (based on academic literature):
 * - Crash: Bottom 10% of returns (worst ~3 years out of 30)
 * - Bear: Next 20% (10th to 30th percentile)
 * - Bull: Top 70% (above 30th percentile)
 *
 * @param returns Array of historical annual returns (as decimals, e.g., 0.12 for 12%)
 * @returns Object with bull, bear, crash arrays
 */
export function classifyRegimes(returns: number[]): ClassifiedReturns {
  if (returns.length < 10) {
    throw new Error('Insufficient data for regime classification (minimum 10 observations)');
  }

  // Calculate threshold values
  const crashThreshold = percentile(returns, 10);  // Bottom 10%
  const bearThreshold = percentile(returns, 30);   // Next 20%

  const bull: number[] = [];
  const bear: number[] = [];
  const crash: number[] = [];

  for (const r of returns) {
    if (r < crashThreshold) {
      crash.push(r);
    } else if (r < bearThreshold) {
      bear.push(r);
    } else {
      bull.push(r);
    }
  }

  return { bull, bear, crash };
}

/**
 * Estimate regime parameters (mean, stddev) from classified returns
 *
 * @param classified Classified returns from classifyRegimes()
 * @returns Regime parameters map with mean/stddev for each regime
 */
export function estimateRegimeParams(classified: ClassifiedReturns): RegimeParamsMap {
  // Ensure each regime has enough observations
  const minObs = 2; // Need at least 2 for stddev

  return {
    bull: {
      mean: classified.bull.length >= minObs ? mean(classified.bull) : 0.10,
      stddev: classified.bull.length >= minObs ? stddev(classified.bull) : 0.12,
    },
    bear: {
      mean: classified.bear.length >= minObs ? mean(classified.bear) : -0.05,
      stddev: classified.bear.length >= minObs ? stddev(classified.bear) : 0.15,
    },
    crash: {
      mean: classified.crash.length >= minObs ? mean(classified.crash) : -0.25,
      stddev: classified.crash.length >= minObs ? stddev(classified.crash) : 0.30,
    },
  };
}

/**
 * Calibrate regime model from historical returns
 *
 * Complete calibration workflow: historical data -> regime parameters
 * This is the main entry point for deriving asset-specific regime parameters.
 *
 * @param historicalReturns Array of historical annual returns
 * @returns Regime parameters derived from the data
 */
export function calibrateRegimeModel(historicalReturns: number[]): RegimeParamsMap {
  const classified = classifyRegimes(historicalReturns);
  return estimateRegimeParams(classified);
}

/**
 * Calculate portfolio-level regime parameters from multiple assets
 *
 * Derives weighted regime parameters for a portfolio based on:
 * - Individual asset regime parameters
 * - Portfolio weights
 * - Asset correlation matrix
 *
 * @param assetParams Array of regime parameters (one per asset)
 * @param weights Array of portfolio weights (must sum to 1)
 * @param correlationMatrix NxN correlation matrix
 * @returns Portfolio-level regime parameters
 */
export function calculatePortfolioRegimeParams(
  assetParams: RegimeParamsMap[],
  weights: number[],
  correlationMatrix: number[][]
): RegimeParamsMap {
  const regimes: MarketRegime[] = ['bull', 'bear', 'crash'];
  const result = {} as RegimeParamsMap;

  for (const regime of regimes) {
    // Weighted average return
    const portfolioMean = assetParams.reduce(
      (sum, params, i) => sum + params[regime].mean * weights[i],
      0
    );

    // Portfolio variance using correlation matrix
    let portfolioVariance = 0;
    for (let i = 0; i < weights.length; i++) {
      for (let j = 0; j < weights.length; j++) {
        portfolioVariance +=
          weights[i] * weights[j] *
          assetParams[i][regime].stddev *
          assetParams[j][regime].stddev *
          correlationMatrix[i][j];
      }
    }

    result[regime] = {
      mean: portfolioMean,
      stddev: Math.sqrt(Math.max(0, portfolioVariance)),
    };
  }

  return result;
}
```

Key implementation notes:
- Use existing math module functions (mean, stddev, percentile)
- Threshold classification based on research (10/30 percentile split)
- Fallback values if regime has insufficient observations
- Portfolio-level calculation uses correlation matrix for proper variance
  </action>
  <verify>
1. File exists: `ls src/simulation/regime-calibration.ts`
2. TypeScript compiles: `npx tsc --noEmit`
3. Exports are correct: `grep "export function" src/simulation/regime-calibration.ts` shows 4 functions
  </verify>
  <done>
- regime-calibration.ts created with classifyRegimes, estimateRegimeParams, calibrateRegimeModel, calculatePortfolioRegimeParams
- All functions properly typed with TypeScript
- Uses existing math module for statistical calculations
  </done>
</task>

<task type="auto">
  <name>Task 2: Export calibration module from simulation barrel</name>
  <files>src/simulation/index.ts</files>
  <action>
Update `src/simulation/index.ts` to export the new calibration module:

Add export line:
```typescript
export * from './regime-calibration';
```

This makes the calibration functions available via the simulation module barrel export.
  </action>
  <verify>
1. `grep "regime-calibration" src/simulation/index.ts` shows export line
2. `npm run build` succeeds
  </verify>
  <done>
- regime-calibration exports added to simulation barrel
- Build succeeds without errors
  </done>
</task>

</tasks>

<verification>
- `npm run build` completes without errors
- `npx tsc --noEmit` type checks pass
- All 4 calibration functions are exported and accessible
</verification>

<success_criteria>
1. regime-calibration.ts exists with classifyRegimes, estimateRegimeParams, calibrateRegimeModel, calculatePortfolioRegimeParams
2. Functions use existing math module (mean, stddev, percentile)
3. Threshold classification uses 10/30 percentile split
4. Portfolio-level calculation accounts for correlation matrix
5. Module exported from simulation barrel
6. Application builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/18-fix-regime-switching/18-02-SUMMARY.md`
</output>
