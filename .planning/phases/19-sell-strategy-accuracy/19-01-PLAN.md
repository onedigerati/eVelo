---
phase: 19-sell-strategy-accuracy
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/calculations/sell-strategy.ts
autonomous: true

must_haves:
  truths:
    - "Sell strategy applies withdrawal BEFORE returns in each year"
    - "Terminal values for Sell are lower than current (order fix is less favorable)"
    - "Depletion probability increases after fix (more realistic)"
  artifacts:
    - path: "src/calculations/sell-strategy.ts"
      provides: "Corrected order of operations"
      contains: "portfolioValue -= grossSale"
  key_links:
    - from: "runSingleSellScenario"
      to: "year loop"
      via: "withdrawal before growth"
      pattern: "portfolioValue -= grossSale.*portfolioValue \\*= \\(1 \\+ growthRate\\)"
---

<objective>
Fix the order of operations in sell strategy simulation to match reference implementation.

Purpose: The current implementation applies market returns BEFORE withdrawals, making the Sell strategy appear more favorable than reality. The correct order is: withdrawal + taxes FIRST, then returns applied to the reduced portfolio.

Output: Updated sell-strategy.ts with corrected order of operations in runSingleSellScenario and runInterpolatedScenario functions.
</objective>

<execution_context>
@C:\Users\ungac\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ungac\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-sell-strategy-accuracy/19-RESEARCH.md
@src/calculations/sell-strategy.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix order in runSingleSellScenario</name>
  <files>src/calculations/sell-strategy.ts</files>
  <action>
Modify the `runSingleSellScenario` function to change the order of operations in the year loop:

CURRENT ORDER (wrong):
1. Apply growth rate (line ~260)
2. Calculate and apply withdrawal + taxes (lines ~264-300)

CORRECT ORDER:
1. Check for depletion (existing early exit)
2. Calculate and apply withdrawal + taxes (move this BEFORE growth)
3. Apply growth rate to REDUCED portfolio (move AFTER withdrawal)

Specifically in the for loop starting at line 238:
- Keep the early depletion check (lines 239-243)
- Move the withdrawal logic (lines 264-300) BEFORE the growth calculation
- Move the growth calculation (lines 246-261) AFTER the withdrawal

The structure should be:
```typescript
for (let year = 1; year <= timeHorizon; year++) {
  if (portfolioValue <= 0) { /* early exit */ }

  // 1. WITHDRAWAL FIRST (moved up)
  const adjustedWithdrawal = currentWithdrawal;
  currentWithdrawal *= (1 + withdrawalGrowth);

  if (adjustedWithdrawal >= portfolioValue) { /* full depletion */ }

  const saleAmount = adjustedWithdrawal;
  const basisSold = costBasis * (saleAmount / portfolioValue);
  const gain = saleAmount - basisSold;
  const tax = gain > 0 ? gain * capitalGainsRate : 0;
  totalTaxes += tax;

  const grossSale = saleAmount + tax;

  if (grossSale >= portfolioValue) { /* depleted after taxes */ }

  const saleFraction = grossSale / portfolioValue;
  portfolioValue -= grossSale;
  costBasis *= (1 - saleFraction);

  // 2. GROWTH APPLIED TO REDUCED PORTFOLIO (moved down)
  const yearData = yearlyPercentiles[year];
  const prevYearData = yearlyPercentiles[year - 1];
  if (!yearData || !prevYearData) {
    portfolioValue *= 1.07; // fallback
  } else {
    const prevValue = prevYearData[percentileKey];
    const currValue = yearData[percentileKey];
    const growthRate = prevValue > 0 ? (currValue - prevValue) / prevValue : 0;
    portfolioValue *= (1 + growthRate);
  }

  yearlyValues.push(portfolioValue);
}
```

Add a comment at the top of the function explaining the order:
```typescript
// Order of operations (matches reference implementation):
// 1. Withdrawal + capital gains tax reduces portfolio
// 2. Market returns applied to reduced portfolio
// This order is less favorable to Sell strategy than applying returns first.
```
  </action>
  <verify>
Build passes: `npm run build` completes without TypeScript errors.
  </verify>
  <done>
runSingleSellScenario applies withdrawal BEFORE returns, with explanatory comment.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix order in runInterpolatedScenario</name>
  <files>src/calculations/sell-strategy.ts</files>
  <action>
Apply the same order-of-operations fix to `runInterpolatedScenario` function (starts around line 358).

The structure mirrors runSingleSellScenario but uses interpolated growth rates. Apply the same reordering:

1. Keep early depletion check
2. Move withdrawal logic BEFORE growth
3. Move growth calculation AFTER withdrawal

The interpolated growth calculation uses weighted average between two percentile paths - this logic stays the same, just moves after withdrawal:

```typescript
for (let year = 1; year <= timeHorizon; year++) {
  if (portfolioValue <= 0) { /* early exit */ }

  // 1. WITHDRAWAL FIRST
  const adjustedWithdrawal = currentWithdrawal;
  currentWithdrawal *= (1 + withdrawalGrowth);

  if (adjustedWithdrawal >= portfolioValue) { /* full depletion */ }

  const saleAmount = adjustedWithdrawal;
  const basisSold = costBasis * (saleAmount / portfolioValue);
  const gain = saleAmount - basisSold;
  const tax = gain > 0 ? gain * capitalGainsRate : 0;
  totalTaxes += tax;

  const grossSale = saleAmount + tax;

  if (grossSale >= portfolioValue) { /* depleted */ }

  const saleFraction = grossSale / portfolioValue;
  portfolioValue -= grossSale;
  costBasis *= (1 - saleFraction);

  // 2. GROWTH APPLIED TO REDUCED PORTFOLIO
  const yearData = yearlyPercentiles[year];
  const prevYearData = yearlyPercentiles[year - 1];
  if (!yearData || !prevYearData) {
    portfolioValue *= 1.07;
  } else {
    // Interpolate between percentile paths (unchanged logic)
    const lowerPrev = prevYearData[lowerKey];
    const lowerCurr = yearData[lowerKey];
    const upperPrev = prevYearData[upperKey];
    const upperCurr = yearData[upperKey];
    const prevValue = lowerPrev + (upperPrev - lowerPrev) * weight;
    const currValue = lowerCurr + (upperCurr - lowerCurr) * weight;
    const growthRate = prevValue > 0 ? (currValue - prevValue) / prevValue : 0;
    portfolioValue *= (1 + growthRate);
  }

  yearlyValues.push(portfolioValue);
}
```
  </action>
  <verify>
Build passes: `npm run build` completes without TypeScript errors.
Run simulation and verify Sell terminal values are lower than before the fix.
  </verify>
  <done>
Both scenario functions apply withdrawal before returns, ensuring consistent behavior.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. Manual verification: Run simulation with typical parameters ($5M initial, $200K withdrawal, 30 years)
   - Sell strategy terminal values should be LOWER than before the fix
   - Depletion probability should be HIGHER (more realistic)
3. Both runSingleSellScenario and runInterpolatedScenario have consistent order
</verification>

<success_criteria>
- Sell strategy simulation applies withdrawal BEFORE market returns in each year
- Build compiles without errors
- Order matches reference implementation (withdrawal -> returns)
- Explanatory comments document the order of operations
</success_criteria>

<output>
After completion, create `.planning/phases/19-sell-strategy-accuracy/19-01-SUMMARY.md`
</output>
