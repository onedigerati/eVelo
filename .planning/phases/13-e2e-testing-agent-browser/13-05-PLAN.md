---
phase: 13-e2e-testing-agent-browser
plan: 05
type: execute
wave: 3
depends_on: ["13-03"]
files_modified:
  - test/e2e/charts.js
autonomous: false

must_haves:
  truths:
    - "Chart test runs simulation to generate chart data"
    - "Chart test verifies all 11 chart types have data via evalJs"
    - "Baseline screenshots captured after simulation"
    - "Test uses pixelmatch for screenshot comparison in verify mode"
  artifacts:
    - path: "test/e2e/charts.js"
      provides: "Chart baseline capture and visual regression test"
      min_lines: 120
  key_links:
    - from: "test/e2e/charts.js"
      to: "test/e2e/helpers/screenshot.js"
      via: "import compareScreenshots"
      pattern: "import.*screenshot"
    - from: "test/e2e/charts.js"
      to: "Chart.js"
      via: "evalJs chart.data"
      pattern: "evalJs.*chart"
---

<objective>
Create chart baseline screenshot capture and visual regression test for all 11 chart types in eVelo.

Purpose: Establish visual regression baselines for Chart.js canvas-based charts. Since canvas content is not in the DOM, screenshots with pixelmatch comparison are the primary verification method.
Output: Chart test script that captures baselines (--capture mode) and verifies against baselines (default mode).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/13-e2e-testing-agent-browser/13-RESEARCH.md
@.planning/phases/13-e2e-testing-agent-browser/13-01-SUMMARY.md
@.planning/phases/13-e2e-testing-agent-browser/13-03-SUMMARY.md
@src/charts/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create chart visual regression test</name>
  <files>test/e2e/charts.js</files>
  <action>
  Create test that captures baseline screenshots and verifies against them using pixelmatch:

  ```javascript
  // test/e2e/charts.js
  // Chart visual regression test with baseline capture
  import { startServer, stopServer, getBaseUrl } from './helpers/server.js';
  import {
    open, close, isVisible, screenshot, wait, findRole, findLabel, evalJs
  } from './helpers/agent-browser.js';
  import { compareScreenshots, hasBaseline } from './helpers/screenshot.js';
  import fs from 'fs';
  import path from 'path';

  // All 11 chart types in eVelo (from src/charts/)
  const CHART_COMPONENTS = [
    // Core results charts (always visible after simulation)
    { element: 'probability-cone-chart', name: 'probability-cone', section: 'core' },
    { element: 'histogram-chart', name: 'histogram', section: 'core' },
    { element: 'donut-chart', name: 'donut', section: 'core' },
    { element: 'correlation-heatmap', name: 'correlation-heatmap', section: 'core' },

    // SBLOC charts (visible when withdrawal > 0)
    { element: 'margin-call-chart', name: 'margin-call', section: 'sbloc' },
    { element: 'sbloc-balance-chart', name: 'sbloc-balance', section: 'sbloc' },
    { element: 'bbd-comparison-chart', name: 'bbd-comparison', section: 'sbloc' },

    // Strategy comparison charts
    { element: 'comparison-line-chart', name: 'comparison-line', section: 'strategy' },
    { element: 'cumulative-costs-chart', name: 'cumulative-costs', section: 'strategy' },
    { element: 'terminal-comparison-chart', name: 'terminal-comparison', section: 'strategy' },
    { element: 'sbloc-utilization-chart', name: 'sbloc-utilization', section: 'strategy' },
  ];

  // Test parameters for simulation
  const TEST_PARAMS = {
    initialPortfolio: '1000000',
    timeHorizon: '30',
    annualWithdrawal: '50000',  // Enables SBLOC charts
  };

  // Paths
  const BASELINE_DIR = 'test/e2e/screenshots/baseline';
  const CURRENT_DIR = 'test/e2e/screenshots/current';
  const DIFF_DIR = 'test/e2e/screenshots/diff';

  // Mode: 'capture' for creating baselines, 'verify' for checking against baselines
  const MODE = process.argv.includes('--capture') ? 'capture' : 'verify';

  async function runChartTest() {
    console.log('========================================');
    console.log(`eVelo Chart Test (${MODE.toUpperCase()} mode)`);
    console.log('========================================\n');

    let passed = 0;
    let failed = 0;
    let captured = 0;
    let skipped = 0;

    // Ensure directories exist
    [BASELINE_DIR, CURRENT_DIR, DIFF_DIR].forEach(dir => {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
    });

    try {
      // Start server
      await startServer();

      // Open application
      await open(getBaseUrl());
      await wait('main-layout', { timeout: 10000 });

      // Set parameters to get full chart data
      console.log('[Setup] Setting simulation parameters...\n');

      try {
        await findLabel('Initial Portfolio', 'fill', TEST_PARAMS.initialPortfolio);
        console.log(`  Set Initial Portfolio: $${TEST_PARAMS.initialPortfolio}`);
      } catch (e) {
        console.log(`  [WARN] Could not set Initial Portfolio: ${e.message}`);
      }

      try {
        await findLabel('Time Horizon', 'fill', TEST_PARAMS.timeHorizon);
        console.log(`  Set Time Horizon: ${TEST_PARAMS.timeHorizon} years`);
      } catch (e) {
        console.log(`  [WARN] Could not set Time Horizon: ${e.message}`);
      }

      try {
        await findLabel('Annual Withdrawal', 'fill', TEST_PARAMS.annualWithdrawal);
        console.log(`  Set Annual Withdrawal: $${TEST_PARAMS.annualWithdrawal}`);
      } catch (e) {
        console.log(`  [INFO] Annual Withdrawal not directly accessible`);
      }

      // Run simulation
      console.log('\n[Setup] Running simulation...');
      await findRole('button', 'click', 'Run');
      await wait('key-metrics-banner', { timeout: 60000 });
      console.log('  Simulation complete\n');

      // Wait for charts to render (Chart.js animations)
      await new Promise(r => setTimeout(r, 2000));

      // Process each chart
      console.log('[Charts] Processing chart components...\n');

      for (const chart of CHART_COMPONENTS) {
        const baselinePath = path.join(BASELINE_DIR, `${chart.name}.png`);
        const currentPath = path.join(CURRENT_DIR, `${chart.name}.png`);
        const diffPath = path.join(DIFF_DIR, `${chart.name}.png`);

        try {
          // Check if chart is visible
          const visible = await isVisible(chart.element);

          if (!visible) {
            console.log(`  [SKIP] ${chart.name} - not visible (${chart.section} section)`);
            skipped++;
            continue;
          }

          // Verify chart has data via Chart.js API
          const hasData = await evalJs(`
            const el = document.querySelector('${chart.element}');
            if (el && el.shadowRoot) {
              const canvas = el.shadowRoot.querySelector('canvas');
              if (canvas && canvas.chart) {
                return canvas.chart.data.datasets.length > 0;
              }
            }
            return false;
          `);

          if (hasData !== true && hasData !== 'true') {
            console.log(`  [WARN] ${chart.name} - visible but no data`);
            skipped++;
            continue;
          }

          if (MODE === 'capture') {
            // Capture mode: save as baseline
            // Note: agent-browser screenshot captures full page
            // We capture full dashboard and document which charts are where
            console.log(`  [CAPTURE] ${chart.name} - visible with data`);
            captured++;
          } else {
            // Verify mode: check against baseline
            console.log(`  [PASS] ${chart.name} - visible with data`);
            passed++;
          }

        } catch (e) {
          console.log(`  [FAIL] ${chart.name} - ${e.message}`);
          failed++;
        }
      }

      // Capture/verify full dashboard screenshots
      console.log('\n[Dashboard] Full page screenshots...\n');

      // Top of dashboard
      const dashboardTopBaseline = path.join(BASELINE_DIR, 'dashboard-top.png');
      const dashboardTopCurrent = path.join(CURRENT_DIR, 'dashboard-top.png');
      const dashboardTopDiff = path.join(DIFF_DIR, 'dashboard-top.png');

      await screenshot(dashboardTopCurrent);

      if (MODE === 'capture') {
        // Copy current to baseline
        fs.copyFileSync(dashboardTopCurrent, dashboardTopBaseline);
        console.log('  [CAPTURE] dashboard-top.png baseline saved');
        captured++;
      } else if (hasBaseline('dashboard-top', BASELINE_DIR)) {
        // Compare against baseline
        try {
          const result = await compareScreenshots(
            dashboardTopBaseline,
            dashboardTopCurrent,
            dashboardTopDiff,
            0.1  // 10% threshold for anti-aliasing
          );

          if (result.match) {
            console.log('  [PASS] dashboard-top.png - no visual differences');
            passed++;
          } else {
            console.log(`  [FAIL] dashboard-top.png - ${result.diffPixels} pixels differ (${result.diffPercent.toFixed(2)}%)`);
            console.log(`         Diff saved to: ${dashboardTopDiff}`);
            failed++;
          }
        } catch (e) {
          console.log(`  [FAIL] dashboard-top.png comparison failed: ${e.message}`);
          failed++;
        }
      } else {
        console.log('  [SKIP] dashboard-top.png - no baseline (run with --capture first)');
        skipped++;
      }

      // Scroll to bottom and capture
      await evalJs('window.scrollTo(0, document.body.scrollHeight)');
      await new Promise(r => setTimeout(r, 500));

      const dashboardBottomBaseline = path.join(BASELINE_DIR, 'dashboard-bottom.png');
      const dashboardBottomCurrent = path.join(CURRENT_DIR, 'dashboard-bottom.png');
      const dashboardBottomDiff = path.join(DIFF_DIR, 'dashboard-bottom.png');

      await screenshot(dashboardBottomCurrent);

      if (MODE === 'capture') {
        fs.copyFileSync(dashboardBottomCurrent, dashboardBottomBaseline);
        console.log('  [CAPTURE] dashboard-bottom.png baseline saved');
        captured++;
      } else if (hasBaseline('dashboard-bottom', BASELINE_DIR)) {
        try {
          const result = await compareScreenshots(
            dashboardBottomBaseline,
            dashboardBottomCurrent,
            dashboardBottomDiff,
            0.1
          );

          if (result.match) {
            console.log('  [PASS] dashboard-bottom.png - no visual differences');
            passed++;
          } else {
            console.log(`  [FAIL] dashboard-bottom.png - ${result.diffPixels} pixels differ (${result.diffPercent.toFixed(2)}%)`);
            console.log(`         Diff saved to: ${dashboardBottomDiff}`);
            failed++;
          }
        } catch (e) {
          console.log(`  [FAIL] dashboard-bottom.png comparison failed: ${e.message}`);
          failed++;
        }
      } else {
        console.log('  [SKIP] dashboard-bottom.png - no baseline (run with --capture first)');
        skipped++;
      }

      // Summary
      console.log('\n========================================');
      if (MODE === 'capture') {
        console.log(`Chart Capture Complete: ${captured} baselines captured`);
        console.log('Baselines saved to: test/e2e/screenshots/baseline/');
      } else {
        console.log(`Chart Test Complete: ${passed} passed, ${failed} failed, ${skipped} skipped`);
      }
      console.log('========================================');

      return failed === 0;

    } catch (e) {
      console.error('\n[ERROR] Chart test failed:', e.message);
      return false;

    } finally {
      // Cleanup
      try {
        await close();
      } catch {
        // Ignore close errors
      }
      await stopServer();
    }
  }

  // Run test
  runChartTest()
    .then(success => process.exit(success ? 0 : 1))
    .catch(err => {
      console.error('Chart test error:', err);
      process.exit(1);
    });
  ```

  Key aspects from research:
  - Chart.js renders to canvas - content not in accessibility tree
  - Use evalJs to verify chart.data.datasets exists
  - Use pixelmatch via compareScreenshots for visual regression
  - Two modes: --capture for baseline creation, default for verification
  - SBLOC charts only visible when withdrawal > 0
  - 10% threshold for anti-aliasing tolerance
  </action>
  <verify>
  - File exists at test/e2e/charts.js
  - No syntax errors: node --check test/e2e/charts.js
  - Imports from ./helpers/screenshot.js (compareScreenshots, hasBaseline)
  - Uses --capture flag for baseline mode
  </verify>
  <done>Chart visual regression test created with baseline capture and pixelmatch comparison</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Chart visual regression test with baseline capture and pixelmatch comparison</what-built>
  <how-to-verify>
  1. Run baseline capture: npm run test:e2e:charts:capture
  2. Verify:
     - Server starts
     - Simulation runs (may take 30-60 seconds)
     - Charts verified (visible with data)
     - Screenshots captured to test/e2e/screenshots/baseline/
  3. Check screenshots exist:
     - test/e2e/screenshots/baseline/dashboard-top.png
     - test/e2e/screenshots/baseline/dashboard-bottom.png
  4. Review screenshots show charts with actual data (not empty placeholders)
  5. (Optional) Run verify mode: npm run test:e2e:charts
     - Should show all PASS if baselines exist and nothing changed
  </how-to-verify>
  <resume-signal>Type "approved" if baselines captured correctly, or describe issues</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:
1. test/e2e/charts.js exists with 120+ lines
2. No syntax errors in charts.js
3. Test runs simulation to generate chart data
4. Test verifies all 11 chart components have data via evalJs
5. Test captures dashboard screenshots (top and bottom)
6. Test uses pixelmatch for comparison in verify mode
7. Baseline screenshots exist in screenshots/baseline/
</verification>

<success_criteria>
1. Chart test verifies probability-cone-chart, histogram-chart, donut-chart, correlation-heatmap
2. Chart test verifies SBLOC charts when enabled (margin-call, sbloc-balance, bbd-comparison)
3. Chart test verifies strategy charts (comparison-line, cumulative-costs, terminal-comparison, sbloc-utilization)
4. Baseline capture mode (--capture) saves screenshots to baseline/
5. Verify mode compares against baselines using pixelmatch with 0.1 threshold
6. Diff images saved when comparison fails
</success_criteria>

<output>
After completion, create `.planning/phases/13-e2e-testing-agent-browser/13-05-SUMMARY.md`
</output>
