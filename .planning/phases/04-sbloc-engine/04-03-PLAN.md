---
phase: 04-sbloc-engine
plan: 03
type: execute
wave: 3
depends_on: ["04-01", "04-02"]
files_modified:
  - src/sbloc/liquidation.ts
  - src/sbloc/engine.ts
  - src/sbloc/index.ts
autonomous: true

must_haves:
  truths:
    - "Forced liquidation sells correct amount to restore safe LTV"
    - "Liquidation haircut is applied to assets sold"
    - "SBLOC engine steps through one year correctly (interest + withdrawal + checks)"
    - "Complete SBLOC year returns updated state with potential liquidation event"
  artifacts:
    - path: "src/sbloc/liquidation.ts"
      provides: "Forced liquidation calculation and execution"
      min_lines: 60
      exports: ["calculateLiquidationAmount", "executeForcedLiquidation", "calculateHaircutLoss"]
    - path: "src/sbloc/engine.ts"
      provides: "SBLOC simulation step function"
      min_lines: 80
      exports: ["stepSBLOC", "initializeSBLOCState"]
    - path: "src/sbloc/index.ts"
      provides: "Barrel export for sbloc module"
      min_lines: 15
      exports: ["stepSBLOC", "initializeSBLOCState", "SBLOCConfig", "SBLOCState"]
  key_links:
    - from: "src/sbloc/engine.ts"
      to: "src/sbloc/interest.ts"
      via: "calls accrueInterest"
      pattern: "import.*accrueInterest.*from.*interest"
    - from: "src/sbloc/engine.ts"
      to: "src/sbloc/margin-call.ts"
      via: "calls detectMarginCall"
      pattern: "import.*detectMarginCall.*from.*margin-call"
    - from: "src/sbloc/engine.ts"
      to: "src/sbloc/liquidation.ts"
      via: "calls executeForcedLiquidation"
      pattern: "import.*executeForcedLiquidation.*from.*liquidation"
---

<objective>
Create forced liquidation logic and SBLOC engine integration.

Purpose: Implement forced liquidation when margin calls cannot be met (SBLOC-05) and create the main SBLOC step function that advances the simulation by one year, enabling loan balance trajectory tracking (SBLOC-06).

Output: Complete SBLOC module with step function that can be integrated into the Monte Carlo simulation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-sbloc-engine/04-01-SUMMARY.md
@.planning/phases/04-sbloc-engine/04-02-SUMMARY.md

# Reference implementation patterns (from PortfolioStrategySimulator.html):
#
# Forced liquidation process:
# 1. Target LTV after liquidation: maintenanceMargin * 0.8 (80% of maintenance)
# 2. targetLoc = portfolioValue * targetLTV
# 3. excessLoc = locBalance - targetLoc
# 4. assetsToSell = excessLoc / (1 - liquidationHaircut)
# 5. Apply haircut: proceeds = assetsToSell * (1 - haircut)
# 6. Update: portfolioValue -= assetsToSell; locBalance -= proceeds
# 7. If netPortfolio <= 0 after liquidation: simulation fails
#
# Year step order:
# 1. If year >= startYear: add withdrawal to loan balance
# 2. Apply interest to loan balance
# 3. Check for margin call
# 4. If margin call: execute forced liquidation
# 5. Return updated state

@src/sbloc/types.ts
@src/sbloc/interest.ts
@src/sbloc/ltv.ts
@src/sbloc/margin-call.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create forced liquidation module</name>
  <files>src/sbloc/liquidation.ts</files>
  <action>
Create forced liquidation calculation and execution:

**calculateLiquidationAmount(state: SBLOCState, config: SBLOCConfig): { assetsToSell: number; loanToRepay: number; targetLTV: number }**
- Calculate how much to liquidate to restore safe LTV
- Target LTV = maintenanceMargin * 0.8 (80% of maintenance for safety buffer)
- excessLoan = loanBalance - (portfolioValue * targetLTV)
- assetsToSell = excessLoan / (1 - liquidationHaircut)
- loanToRepay = assetsToSell * (1 - liquidationHaircut)
- If excessLoan <= 0, return zeros (no liquidation needed)

**calculateHaircutLoss(assetsLiquidated: number, haircutRate: number): number**
- Returns the dollar amount lost to haircut
- Formula: assetsLiquidated * haircutRate
- Example: $200k liquidated * 5% haircut = $10k loss

**executeForcedLiquidation(state: SBLOCState, config: SBLOCConfig): { newState: SBLOCState; event: LiquidationEvent; portfolioFailed: boolean }**
- Execute the liquidation and return new state
- Steps:
  1. Calculate liquidation amounts
  2. Reduce portfolioValue by assetsToSell
  3. Reduce loanBalance by proceeds (after haircut)
  4. Recalculate currentLTV
  5. Check if portfolio failed (netWorth <= 0)
- Return new state (immutable - don't mutate input)
- Return LiquidationEvent with all details
- portfolioFailed = true if net worth (portfolio - loan) <= 0

**canRecoverFromMarginCall(state: SBLOCState, config: SBLOCConfig): boolean**
- Returns false if liquidating all assets can't cover the loan
- Formula: portfolioValue * (1 - haircut) < loanBalance → can't recover
- This is terminal portfolio failure

Include JSDoc with step-by-step examples. Pure functions.
  </action>
  <verify>npm run build succeeds, liquidation math is correct</verify>
  <done>Liquidation correctly calculates amounts; $1M portfolio, $700k loan, 65% max, 5% haircut → sells ~$400k, repays ~$380k, new LTV drops to safe level</done>
</task>

<task type="auto">
  <name>Task 2: Create SBLOC engine and barrel export</name>
  <files>src/sbloc/engine.ts, src/sbloc/index.ts</files>
  <action>
Create the main SBLOC step function and module barrel export:

**src/sbloc/engine.ts:**

**initializeSBLOCState(config: SBLOCConfig, initialPortfolioValue: number, initialLoanBalance?: number): SBLOCState**
- Create initial state for simulation
- loanBalance = initialLoanBalance ?? 0
- portfolioValue = initialPortfolioValue
- currentLTV = calculateLTV(loanBalance, portfolioValue)
- inWarningZone = isInWarningZone(state, config)
- yearsSinceStart = 0

**SBLOCYearResult interface:**
- newState: SBLOCState
- marginCallTriggered: boolean
- liquidationEvent: LiquidationEvent | null
- portfolioFailed: boolean
- interestCharged: number
- withdrawalMade: number

**stepSBLOC(state: SBLOCState, config: SBLOCConfig, portfolioReturn: number, currentYear: number): SBLOCYearResult**
Main simulation step - advances SBLOC state by one year:

1. Apply portfolio return first:
   - newPortfolioValue = portfolioValue * (1 + portfolioReturn)

2. If currentYear >= config.startYear (BBD has started):
   a. Add annual withdrawal to loan balance
   b. Apply interest based on compounding frequency

3. Update currentLTV

4. Check for margin call:
   - If LTV >= maxLTV: execute forced liquidation
   - Track if liquidation occurred
   - Check if portfolio failed

5. Update warning zone status

6. Return SBLOCYearResult with:
   - New state (immutable)
   - Whether margin call triggered
   - Liquidation event details (if any)
   - Whether portfolio failed
   - Interest charged this year
   - Withdrawal made this year

**src/sbloc/index.ts:**

Barrel export for clean API:
```typescript
// Types
export type { SBLOCConfig, SBLOCState, MarginCallEvent, LiquidationEvent, LTVByAssetClass } from './types';

// Core functions
export { accrueInterest, calculateAnnualInterest, calculateMonthlyInterest, projectLoanBalance } from './interest';
export { calculateLTV, calculateMaxBorrowing, getEffectiveLTV, isWithinBorrowingLimit, calculateAvailableCredit } from './ltv';
export { detectMarginCall, isInWarningZone, calculateMarginBuffer, calculateDropToMarginCall } from './margin-call';
export { calculateLiquidationAmount, calculateHaircutLoss, executeForcedLiquidation, canRecoverFromMarginCall } from './liquidation';

// Engine
export { initializeSBLOCState, stepSBLOC } from './engine';
export type { SBLOCYearResult } from './engine';
```

Include JSDoc with full year simulation example.
  </action>
  <verify>npm run build succeeds, stepSBLOC importable from sbloc module</verify>
  <done>Complete SBLOC year step works: $1M portfolio, 10% return, $50k withdrawal, 7.4% rate → new balance calculated correctly; margin call triggers and liquidates when needed</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run build succeeds without errors
- [ ] src/sbloc/liquidation.ts exports calculateLiquidationAmount, calculateHaircutLoss, executeForcedLiquidation, canRecoverFromMarginCall
- [ ] src/sbloc/engine.ts exports initializeSBLOCState, stepSBLOC, SBLOCYearResult
- [ ] src/sbloc/index.ts re-exports all types and functions
- [ ] stepSBLOC correctly sequences: return → withdrawal → interest → margin check → liquidation
- [ ] All imports resolve correctly between modules
- [ ] No TypeScript errors
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Forced liquidation math is accurate
- stepSBLOC integrates all SBLOC components
- SBLOC-05 (forced liquidation) implemented
- SBLOC-06 (loan balance trajectory) trackable via stepSBLOC
- Complete sbloc module ready for integration with Monte Carlo simulation
</success_criteria>

<output>
After completion, create `.planning/phases/04-sbloc-engine/04-03-SUMMARY.md`
</output>
