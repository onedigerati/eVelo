---
phase: 32-historical-asset-data-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/data/schemas/custom-market-data.ts
  - src/data/db.ts
  - src/data/services/custom-data-service.ts
  - src/data/validation/data-validator.ts
  - src/data/services/index.ts
autonomous: true

must_haves:
  truths:
    - "Papa Parse library installed and importable"
    - "Custom market data can be stored in IndexedDB"
    - "CSV content can be validated with specific error messages"
    - "JSON content can be validated with specific error messages"
  artifacts:
    - path: "src/data/schemas/custom-market-data.ts"
      provides: "CustomMarketData interface and schema"
      exports: ["CustomMarketData"]
    - path: "src/data/services/custom-data-service.ts"
      provides: "CRUD operations for custom market data"
      exports: ["saveCustomData", "getCustomData", "getAllCustomData", "deleteCustomData", "resetToDefaults", "hasCustomData"]
    - path: "src/data/validation/data-validator.ts"
      provides: "Validation logic for CSV and JSON imports"
      exports: ["parseAndValidateCsv", "parseAndValidateJson", "ValidationResult", "ValidationError", "ValidationWarning"]
  key_links:
    - from: "src/data/services/custom-data-service.ts"
      to: "src/data/db.ts"
      via: "db.customMarketData table"
      pattern: "db\\.customMarketData"
    - from: "src/data/validation/data-validator.ts"
      to: "papaparse"
      via: "Papa.parse import"
      pattern: "import.*Papa.*from.*papaparse"
---

<objective>
Create the data infrastructure for historical asset data management: install Papa Parse for CSV handling, define custom market data schema, create persistence service, and implement validation module.

Purpose: Establish the foundation for import/export/validation of historical asset data, enabling users to customize simulation inputs.

Output: Working data layer with Papa Parse, IndexedDB persistence for custom data, and comprehensive validation logic.
</objective>

<execution_context>
@C:\Users\ungac\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ungac\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/32-historical-asset-data-management/32-RESEARCH.md

# Existing data layer patterns
@src/data/db.ts
@src/data/services/preset-service.ts
@src/data/schemas/portfolio.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Papa Parse and create custom data schema</name>
  <files>
    package.json
    src/data/schemas/custom-market-data.ts
    src/data/db.ts
  </files>
  <action>
1. Install Papa Parse with TypeScript types:
   ```
   npm install papaparse
   npm install -D @types/papaparse
   ```

2. Create `src/data/schemas/custom-market-data.ts`:
   ```typescript
   import type { PresetReturn } from '../services/preset-service';

   /**
    * Custom market data stored in IndexedDB
    * Extends bundled preset format with metadata tracking
    */
   export interface CustomMarketData {
     id?: number;                    // Auto-increment primary key
     symbol: string;                 // e.g., "SPY", "CUSTOM1"
     name: string;                   // Display name
     assetClass?: string;            // equity_stock, equity_index, bond, etc.
     startDate: string;              // First year/date
     endDate: string;                // Last year/date
     returns: PresetReturn[];        // Array of {date, return}
     importedAt: string;             // ISO timestamp
     source: 'user-import' | 'bundled-modified';
   }
   ```

3. Update `src/data/db.ts` to add customMarketData table:
   - Import CustomMarketData type
   - Add `customMarketData!: EntityTable<CustomMarketData, 'id'>;` property
   - Increment version to 2
   - Add schema: `customMarketData: '++id, symbol, importedAt'`
  </action>
  <verify>
    - `npm list papaparse` shows papaparse installed
    - `npm run build` succeeds with no TypeScript errors
    - CustomMarketData interface exports correctly
  </verify>
  <done>
    Papa Parse installed, CustomMarketData schema defined, database schema updated to version 2 with customMarketData table.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create custom data persistence service</name>
  <files>
    src/data/services/custom-data-service.ts
    src/data/services/index.ts
  </files>
  <action>
Create `src/data/services/custom-data-service.ts`:

```typescript
/**
 * Service for managing custom (user-imported) market data
 *
 * Custom data is stored separately from bundled presets in IndexedDB.
 * When a symbol has custom data, it takes precedence over bundled data.
 */

import { db } from '../db';
import type { CustomMarketData } from '../schemas/custom-market-data';
import type { PresetData } from './preset-service';

/**
 * Save custom market data to IndexedDB
 * If data for this symbol already exists, it will be replaced.
 *
 * @param data - PresetData format from import
 * @param source - Origin of the data
 * @returns The ID of the saved record
 */
export async function saveCustomData(
  data: PresetData,
  source: 'user-import' | 'bundled-modified'
): Promise<number> {
  // Delete existing data for this symbol first
  await deleteCustomData(data.symbol);

  const record: CustomMarketData = {
    symbol: data.symbol.toUpperCase(),
    name: data.name,
    assetClass: data.assetClass,
    startDate: data.startDate,
    endDate: data.endDate,
    returns: data.returns,
    importedAt: new Date().toISOString(),
    source
  };

  return db.customMarketData.add(record) as Promise<number>;
}

/**
 * Get custom data for a specific symbol
 * @returns CustomMarketData if exists, undefined otherwise
 */
export async function getCustomData(symbol: string): Promise<CustomMarketData | undefined> {
  return db.customMarketData.where('symbol').equals(symbol.toUpperCase()).first();
}

/**
 * Get all custom data records
 */
export async function getAllCustomData(): Promise<CustomMarketData[]> {
  return db.customMarketData.toArray();
}

/**
 * Check if custom data exists for a symbol
 */
export async function hasCustomData(symbol: string): Promise<boolean> {
  const count = await db.customMarketData.where('symbol').equals(symbol.toUpperCase()).count();
  return count > 0;
}

/**
 * Delete custom data for a symbol
 */
export async function deleteCustomData(symbol: string): Promise<void> {
  await db.customMarketData.where('symbol').equals(symbol.toUpperCase()).delete();
}

/**
 * Reset to bundled defaults by deleting all custom data for a symbol
 * After this, the bundled preset data will be used again.
 */
export async function resetToDefaults(symbol: string): Promise<void> {
  await deleteCustomData(symbol);
}

/**
 * Get list of symbols that have custom data
 */
export async function getCustomSymbols(): Promise<string[]> {
  const records = await db.customMarketData.toArray();
  return records.map(r => r.symbol);
}
```

Update `src/data/services/index.ts` to export custom data service functions.
  </action>
  <verify>
    - `npm run build` succeeds
    - Service functions are exported from src/data/services/index.ts
  </verify>
  <done>
    Custom data service created with save, get, delete, reset operations. All functions use symbol normalization (uppercase) for consistency.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create data validation module</name>
  <files>
    src/data/validation/data-validator.ts
  </files>
  <action>
Create `src/data/validation/data-validator.ts`:

```typescript
/**
 * Validation module for imported historical market data
 *
 * Supports CSV and JSON formats with comprehensive error reporting.
 * Uses Papa Parse for RFC 4180-compliant CSV handling.
 */

import Papa from 'papaparse';
import type { PresetData, PresetReturn } from '../services/preset-service';

/**
 * Result of validation attempt
 */
export interface ValidationResult {
  valid: boolean;
  data?: PresetData;
  errors: ValidationError[];
  warnings: ValidationWarning[];
}

/**
 * Validation error (blocks import)
 */
export interface ValidationError {
  type: 'format' | 'missing_field' | 'invalid_value' | 'duplicate' | 'insufficient_data';
  row?: number;
  field?: string;
  message: string;
}

/**
 * Validation warning (allows import with caution)
 */
export interface ValidationWarning {
  type: 'anomaly' | 'gap' | 'extreme_value' | 'same_sign';
  row?: number;
  message: string;
}

/**
 * Parse and validate CSV content
 *
 * Expected format:
 * year,annual_return
 * 1995,0.1488
 * 1996,-0.0523
 *
 * @param content - Raw CSV string
 * @param symbol - Symbol to assign to the data
 * @param name - Display name for the data
 */
export function parseAndValidateCsv(
  content: string,
  symbol: string,
  name: string
): ValidationResult {
  const errors: ValidationError[] = [];
  const warnings: ValidationWarning[] = [];

  // Parse CSV with Papa Parse
  const parsed = Papa.parse<{ year: string; annual_return: string }>(content, {
    header: true,
    skipEmptyLines: true,
    transformHeader: (h) => h.trim().toLowerCase().replace(/\s+/g, '_')
  });

  // Check for parse errors
  if (parsed.errors.length > 0) {
    parsed.errors.forEach(e => {
      errors.push({
        type: 'format',
        row: e.row !== undefined ? e.row + 2 : undefined, // +2 for header and 0-index
        message: `CSV format error: ${e.message}`
      });
    });
  }

  // Validate required columns
  const fields = parsed.meta.fields || [];
  const hasYear = fields.includes('year');
  const hasReturn = fields.includes('annual_return');

  if (!hasYear || !hasReturn) {
    const missing = [];
    if (!hasYear) missing.push('year');
    if (!hasReturn) missing.push('annual_return');
    errors.push({
      type: 'missing_field',
      message: `Missing required column(s): ${missing.join(', ')}. Expected: year, annual_return`
    });
    return { valid: false, errors, warnings };
  }

  // Validate each row
  const returns: PresetReturn[] = [];
  const seenYears = new Set<string>();
  let positiveCount = 0;
  let negativeCount = 0;

  parsed.data.forEach((row, index) => {
    const rowNum = index + 2; // Account for header row

    // Validate year format
    const year = row.year?.trim();
    if (!year || !/^\d{4}(-\d{2}-\d{2})?$/.test(year)) {
      errors.push({
        type: 'invalid_value',
        row: rowNum,
        field: 'year',
        message: `Row ${rowNum}: Invalid year format "${year}". Expected YYYY or YYYY-MM-DD.`
      });
      return;
    }

    // Check for duplicates
    if (seenYears.has(year)) {
      errors.push({
        type: 'duplicate',
        row: rowNum,
        field: 'year',
        message: `Row ${rowNum}: Duplicate year "${year}".`
      });
      return;
    }
    seenYears.add(year);

    // Validate return value
    const returnStr = row.annual_return?.trim();
    const returnVal = parseFloat(returnStr);

    if (isNaN(returnVal)) {
      errors.push({
        type: 'invalid_value',
        row: rowNum,
        field: 'annual_return',
        message: `Row ${rowNum}: Invalid return value "${returnStr}". Expected decimal (e.g., 0.10 for 10%).`
      });
      return;
    }

    // Track sign distribution
    if (returnVal >= 0) positiveCount++;
    else negativeCount++;

    // Check for extreme values (warning, not error)
    if (returnVal < -0.9) {
      warnings.push({
        type: 'extreme_value',
        row: rowNum,
        message: `Row ${rowNum}: Return of ${(returnVal * 100).toFixed(1)}% is unusually extreme (< -90%).`
      });
    } else if (returnVal > 3.0) {
      warnings.push({
        type: 'extreme_value',
        row: rowNum,
        message: `Row ${rowNum}: Return of ${(returnVal * 100).toFixed(1)}% is unusually extreme (> 300%).`
      });
    }

    returns.push({ date: year, return: returnVal });
  });

  // Check minimum data requirement
  if (returns.length < 5 && errors.length === 0) {
    errors.push({
      type: 'insufficient_data',
      message: `Insufficient data. Found ${returns.length} rows, minimum 5 years required for simulation.`
    });
  }

  // Check for year gaps (warning)
  const sortedYears = [...seenYears].sort();
  for (let i = 1; i < sortedYears.length; i++) {
    const prev = parseInt(sortedYears[i - 1].substring(0, 4));
    const curr = parseInt(sortedYears[i].substring(0, 4));
    if (curr - prev > 1) {
      warnings.push({
        type: 'gap',
        message: `Missing data between ${prev} and ${curr} (${curr - prev - 1} year gap).`
      });
    }
  }

  // Check for all same sign (warning)
  if (returns.length >= 5) {
    if (positiveCount === returns.length) {
      warnings.push({
        type: 'same_sign',
        message: 'All returns are positive. This is unusual for real market data.'
      });
    } else if (negativeCount === returns.length) {
      warnings.push({
        type: 'same_sign',
        message: 'All returns are negative. This is unusual for real market data.'
      });
    }
  }

  if (errors.length > 0) {
    return { valid: false, errors, warnings };
  }

  // Build result
  const sortedReturns = returns.sort((a, b) => a.date.localeCompare(b.date));
  const data: PresetData = {
    symbol: symbol.toUpperCase(),
    name,
    startDate: sortedReturns[0].date,
    endDate: sortedReturns[sortedReturns.length - 1].date,
    returns: sortedReturns
  };

  return { valid: true, data, errors: [], warnings };
}

/**
 * Parse and validate JSON content
 *
 * Expected format matches PresetData interface with version wrapper
 */
export function parseAndValidateJson(content: string): ValidationResult {
  const errors: ValidationError[] = [];
  const warnings: ValidationWarning[] = [];

  let parsed: unknown;
  try {
    parsed = JSON.parse(content);
  } catch (e) {
    errors.push({
      type: 'format',
      message: `Invalid JSON: ${e instanceof Error ? e.message : 'Parse error'}`
    });
    return { valid: false, errors, warnings };
  }

  const obj = parsed as Record<string, unknown>;

  // Validate required fields
  if (!obj.symbol || typeof obj.symbol !== 'string') {
    errors.push({ type: 'missing_field', field: 'symbol', message: 'Missing or invalid "symbol" field.' });
  }
  if (!obj.name || typeof obj.name !== 'string') {
    errors.push({ type: 'missing_field', field: 'name', message: 'Missing or invalid "name" field.' });
  }
  if (!Array.isArray(obj.returns)) {
    errors.push({ type: 'missing_field', field: 'returns', message: 'Missing or invalid "returns" array.' });
    return { valid: false, errors, warnings };
  }

  // Validate returns array
  const returns: PresetReturn[] = [];
  const seenDates = new Set<string>();
  let positiveCount = 0;
  let negativeCount = 0;

  (obj.returns as Array<{ date?: string; return?: number }>).forEach((item, index) => {
    const rowNum = index + 1;

    if (!item.date || typeof item.date !== 'string') {
      errors.push({
        type: 'invalid_value',
        row: rowNum,
        field: 'date',
        message: `Return #${rowNum}: Missing or invalid "date" field.`
      });
      return;
    }

    if (typeof item.return !== 'number' || isNaN(item.return)) {
      errors.push({
        type: 'invalid_value',
        row: rowNum,
        field: 'return',
        message: `Return #${rowNum}: Missing or invalid "return" value.`
      });
      return;
    }

    if (seenDates.has(item.date)) {
      errors.push({
        type: 'duplicate',
        row: rowNum,
        message: `Return #${rowNum}: Duplicate date "${item.date}".`
      });
      return;
    }
    seenDates.add(item.date);

    // Track sign distribution
    if (item.return >= 0) positiveCount++;
    else negativeCount++;

    // Extreme value warnings
    if (item.return < -0.9 || item.return > 3.0) {
      warnings.push({
        type: 'extreme_value',
        row: rowNum,
        message: `Return #${rowNum}: Value ${(item.return * 100).toFixed(1)}% is unusually extreme.`
      });
    }

    returns.push({ date: item.date, return: item.return });
  });

  // Minimum data check
  if (returns.length < 5 && errors.length === 0) {
    errors.push({
      type: 'insufficient_data',
      message: `Insufficient data. Found ${returns.length} entries, minimum 5 required.`
    });
  }

  // Same sign warning
  if (returns.length >= 5) {
    if (positiveCount === returns.length) {
      warnings.push({ type: 'same_sign', message: 'All returns are positive.' });
    } else if (negativeCount === returns.length) {
      warnings.push({ type: 'same_sign', message: 'All returns are negative.' });
    }
  }

  if (errors.length > 0) {
    return { valid: false, errors, warnings };
  }

  const sortedReturns = returns.sort((a, b) => a.date.localeCompare(b.date));
  const data: PresetData = {
    symbol: (obj.symbol as string).toUpperCase(),
    name: obj.name as string,
    assetClass: typeof obj.assetClass === 'string' ? obj.assetClass : undefined,
    startDate: sortedReturns[0].date,
    endDate: sortedReturns[sortedReturns.length - 1].date,
    returns: sortedReturns
  };

  return { valid: true, data, errors: [], warnings };
}
```

Create directory structure if needed: `src/data/validation/`
  </action>
  <verify>
    - `npm run build` succeeds with no TypeScript errors
    - data-validator.ts exports all expected functions and types
  </verify>
  <done>
    Data validation module complete with CSV (via Papa Parse) and JSON parsing, comprehensive error messages with row numbers, and anomaly warnings for extreme values and gaps.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Build verification:**
   ```
   npm run build
   ```
   Must complete without errors.

2. **Package verification:**
   ```
   npm list papaparse
   ```
   Shows papaparse@5.x installed.

3. **Import verification:**
   In browser console after dev server:
   ```javascript
   // Verify Papa Parse imports
   import('papaparse').then(p => console.log('Papa Parse loaded:', p));

   // Verify custom data service
   import('/src/data/services/custom-data-service.ts').then(m => {
     console.log('Custom data service exports:', Object.keys(m));
   });
   ```
</verification>

<success_criteria>
1. Papa Parse installed and importable in TypeScript
2. CustomMarketData schema defined with all required fields
3. Database schema upgraded to version 2 with customMarketData table
4. Custom data service provides save/get/delete/reset operations
5. CSV validator handles headers, data types, duplicates, gaps, extreme values
6. JSON validator handles structure, types, and anomalies
7. All validation errors include row numbers and specific messages
8. All validation warnings distinguish from blocking errors
</success_criteria>

<output>
After completion, create `.planning/phases/32-historical-asset-data-management/32-01-SUMMARY.md`
</output>
