---
phase: 07.1-application-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/app-root.ts
autonomous: true

must_haves:
  truths:
    - "Run Simulation button triggers actual Monte Carlo simulation"
    - "Progress indicator shows real simulation progress percentage"
    - "Toast notification confirms simulation complete with iteration count"
  artifacts:
    - path: "src/components/app-root.ts"
      provides: "Simulation orchestration connecting UI params to engine"
      contains: "runSimulation"
  key_links:
    - from: "app-root.ts runBtn click"
      to: "simulation/index.ts runSimulation"
      via: "async function call with params from UI"
      pattern: "runSimulation\\("
---

<objective>
Wire the "Run Simulation" button to the actual Monte Carlo simulation engine, collecting parameters from UI components.

Purpose: Transform the demo simulation into a real one that executes Monte Carlo iterations via Web Worker.
Output: app-root.ts that collects UI parameters, runs real simulation, stores results for charts.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Simulation API (from Phase 3):
@src/simulation/index.ts
@src/simulation/types.ts

# Current app-root (has demo simulation):
@src/components/app-root.ts

# UI components for parameter extraction:
@src/components/ui/range-slider.ts
@src/components/ui/number-input.ts
@src/components/ui/select-input.ts
@src/components/ui/weight-editor.ts

# Bundled data for demo returns:
@src/data/services/preset-service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire simulation button to real Monte Carlo engine</name>
  <files>src/components/app-root.ts</files>
  <action>
Replace the demo simulation in afterRender() with real simulation:

1. Import simulation module: `import { runSimulation, SimulationConfig, PortfolioConfig } from '../simulation';`
2. Import preset service for historical returns: `import { getPresetData } from '../data/services/preset-service';`
3. Import charts module: `import '../charts';` (registers custom elements)

4. In the click handler:
   a. Collect parameters from UI components:
      - initialValue from number-input (parse from value attribute)
      - timeHorizon from range-slider (years)
      - iterations from select-input
      - ltvRatio, interestRate from SBLOC section sliders
      - assets/weights from weight-editor

   b. Build SimulationConfig:
      ```typescript
      const config: SimulationConfig = {
        iterations: parseInt(iterationsSelect.value),
        timeHorizon: parseInt(horizonSlider.value),
        initialValue: parseFloat(investmentInput.value),
        inflationRate: 0.03,
        inflationAdjusted: false,
        resamplingMethod: 'simple',
        seed: undefined
      };
      ```

   c. Build PortfolioConfig from weight-editor assets:
      - For each asset in weight-editor, get historical returns from getPresetData(symbol)
      - If no preset data exists, use placeholder returns (warn in console)
      - Build correlationMatrix as identity matrix for now (Phase 9 can refine)

   d. Show progress indicator, call runSimulation with progress callback:
      ```typescript
      const result = await runSimulation(config, portfolio, (percent) => {
        progress.setAttribute('value', String(percent));
      });
      ```

   e. Store result on app-root instance: `this._simulationResult = result;`

   f. Hide progress, show success toast with stats:
      `Simulation complete: ${config.iterations} iterations, median $${formatCurrency(result.statistics.median)}`

5. Add helper method to collect params:
   ```typescript
   private collectSimulationParams(): { config: SimulationConfig; portfolio: PortfolioConfig } {
     // Query shadow DOM for input components, extract values
   }
   ```

6. Add type for storing result: `private _simulationResult: SimulationOutput | null = null;`

AVOID:
- Don't block UI during simulation (runSimulation is already async via worker)
- Don't hardcode asset symbols - read from weight-editor
- Don't crash if preset data missing - use fallback returns with console warning
  </action>
  <verify>
    - npm run build succeeds
    - TypeScript compiles without errors
    - No import errors for simulation or data modules
  </verify>
  <done>
    - Run Simulation button triggers real Monte Carlo via Web Worker
    - Progress indicator updates during simulation
    - Toast shows completion with median value
    - Result stored on component instance for charts (next plan)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add simulation result getter and custom event dispatch</name>
  <files>src/components/app-root.ts</files>
  <action>
After simulation completes, dispatch a custom event so other components can react:

1. After storing `_simulationResult`, dispatch custom event:
   ```typescript
   this.dispatchEvent(new CustomEvent('simulation-complete', {
     detail: { result: this._simulationResult },
     bubbles: true,
     composed: true
   }));
   ```

2. Add public getter for result:
   ```typescript
   get simulationResult(): SimulationOutput | null {
     return this._simulationResult;
   }
   ```

3. Add method to check if simulation is running:
   ```typescript
   private _isRunning = false;
   get isRunning(): boolean {
     return this._isRunning;
   }
   ```

4. Disable Run button during simulation to prevent double-runs:
   ```typescript
   runBtn.disabled = this._isRunning;
   // Set _isRunning = true at start, false after complete
   ```

This enables Plan 02 (results dashboard) to listen for simulation-complete and update charts.
  </action>
  <verify>
    - npm run build succeeds
    - Custom event dispatches (check in browser devtools via event listener)
  </verify>
  <done>
    - simulation-complete event fires after Monte Carlo finishes
    - Run button disabled during simulation
    - simulationResult getter available for other components
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm run dev` starts and page loads
- [ ] Clicking "Run Simulation" triggers real simulation (not demo animation)
- [ ] Progress indicator shows actual simulation progress
- [ ] Toast shows completion with real statistics
</verification>

<success_criteria>
- All tasks completed
- Real Monte Carlo simulation runs via Web Worker
- UI parameters collected from input components
- Progress updates reflect actual simulation progress
- Result stored and event dispatched for chart integration
</success_criteria>

<output>
After completion, create `.planning/phases/07.1-application-integration/07.1-01-SUMMARY.md`
</output>
