---
phase: 23-reference-methodology-alignment
plan: 07
type: execute
wave: 2
depends_on: [23-01, 23-02, 23-03]
files_modified:
  - src/simulation/monte-carlo.ts
  - src/simulation/index.ts
autonomous: true

must_haves:
  truths:
    - "Fat-tail return model available as resampling method"
    - "Fat-tail uses asset class from asset config"
    - "Return clamping prevents extreme unrealistic values"
  artifacts:
    - path: "src/simulation/monte-carlo.ts"
      provides: "Fat-tail return generation in iteration"
      contains: "generateCorrelatedFatTailReturns"
  key_links:
    - from: "src/simulation/monte-carlo.ts"
      to: "src/simulation/fat-tail.ts"
      via: "generateCorrelatedFatTailReturns import"
      pattern: "resamplingMethod.*fat-tail"
---

<objective>
Wire fat-tail return model into Monte Carlo simulation.

Purpose: Plans 23-03 created the fat-tail module. This plan integrates it into the main Monte Carlo simulation so users can select "Fat-Tail" as a return model option, generating returns with heavier tails than normal distributions using asset-class specific parameters.

Output: Monte Carlo simulation supports 'fat-tail' as resamplingMethod, using Student's t-distribution with asset-class differentiation.
</objective>

<execution_context>
@C:\Users\ungac\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ungac\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/23-reference-methodology-alignment/23-03-PLAN.md (creates fat-tail module)
@src/simulation/monte-carlo.ts
@src/simulation/fat-tail.ts
@src/simulation/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire fat-tail model into generateIterationReturns</name>
  <files>src/simulation/monte-carlo.ts</files>
  <action>
Update monte-carlo.ts to support fat-tail return generation:

1. Add import for fat-tail functions:
```typescript
import {
  generateCorrelatedFatTailReturns,
} from './fat-tail';
import type { AssetClass } from './types';
```

2. Update generateIterationReturns to handle 'fat-tail' method:
```typescript
function generateIterationReturns(
  method: SimulationConfig['resamplingMethod'],
  years: number,
  portfolio: PortfolioConfig,
  rng: () => number,
  blockSize?: number,
  regimeCalibration?: RegimeCalibrationMode,
  assetRegimeParams?: RegimeParamsMap[]
): number[][] {
  const numAssets = portfolio.assets.length;

  if (method === 'regime') {
    // ... existing regime code ...
  }

  if (method === 'fat-tail') {
    // Gather asset historical returns and classes
    const assetReturns = portfolio.assets.map(a => a.historicalReturns);
    const assetClasses: AssetClass[] = portfolio.assets.map(
      a => a.assetClass ?? 'equity_index' // Default to equity_index if not specified
    );

    console.log('[MC] Using fat-tail model with asset classes:', assetClasses);

    return generateCorrelatedFatTailReturns(
      assetReturns,
      assetClasses,
      portfolio.correlationMatrix,
      years,
      rng
    );
  }

  // Bootstrap methods with correlation preservation
  const assetReturns = portfolio.assets.map(a => a.historicalReturns);

  if (method === 'block') {
    return correlatedBlockBootstrap(assetReturns, years, rng, blockSize);
  } else {
    // 'simple' bootstrap
    return correlatedBootstrap(assetReturns, years, rng);
  }
}
```

3. Add logging when fat-tail model is selected:
```typescript
// At start of runMonteCarlo, after resamplingMethod check
if (resamplingMethod === 'fat-tail') {
  const assetClasses = portfolio.assets.map(a => a.assetClass ?? 'equity_index');
  console.log(`[MC] Fat-tail model selected with asset classes: ${assetClasses.join(', ')}`);
  console.log('[MC] Student\'s t-distribution parameters by class:');
  assetClasses.forEach((cls, i) => {
    const params = FAT_TAIL_PARAMS[cls];
    console.log(`[MC]   ${portfolio.assets[i].id} (${cls}): df=${params.degreesOfFreedom}, skew=${params.skewMultiplier}, survivorship=${params.survivorshipBias}%`);
  });
}
```
  </action>
  <verify>
Run `npm run build` to verify compilation.
Select "Fat-Tail" return model in UI (if available) or modify config.
Check console for fat-tail model logging.
  </verify>
  <done>
generateIterationReturns handles 'fat-tail' method using Student's t-distribution.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add asset class to debug stats and output</name>
  <files>src/simulation/types.ts, src/simulation/monte-carlo.ts</files>
  <action>
1. Update SBLOCDebugStats to include fat-tail information:
```typescript
export interface SBLOCDebugStats {
  // ... existing fields ...

  /** Fat-tail parameters used (if fat-tail method) */
  fatTailParameters?: {
    assetId: string;
    assetClass: AssetClass;
    degreesOfFreedom: number;
    skewMultiplier: number;
    survivorshipBias: number;
    volatilityScaling: number;
  }[];
}
```

2. In monte-carlo.ts, populate fat-tail debug info:
```typescript
// When building debugStats (after simulation)
if (resamplingMethod === 'fat-tail') {
  debugStats.fatTailParameters = portfolio.assets.map(asset => {
    const cls = asset.assetClass ?? 'equity_index';
    const params = FAT_TAIL_PARAMS[cls];
    return {
      assetId: asset.id,
      assetClass: cls,
      degreesOfFreedom: params.degreesOfFreedom,
      skewMultiplier: params.skewMultiplier,
      survivorshipBias: params.survivorshipBias,
      volatilityScaling: params.volatilityScaling,
    };
  });
}
```

3. Import FAT_TAIL_PARAMS at top of monte-carlo.ts:
```typescript
import { FAT_TAIL_PARAMS } from './types';
```
  </action>
  <verify>
Run `npm run build` to verify compilation.
Run simulation with fat-tail model.
Check debugStats includes fatTailParameters.
  </verify>
  <done>
Debug stats include fat-tail parameters for diagnostics.
  </done>
</task>

<task type="auto">
  <name>Task 3: Export fat-tail from simulation index</name>
  <files>src/simulation/index.ts</files>
  <action>
Ensure all fat-tail exports are available from the simulation module:

```typescript
// In src/simulation/index.ts

// Fat-tail model
export {
  generateFatTailReturn,
  generateCorrelatedFatTailReturns,
  studentT,
} from './fat-tail';

// Also export types
export type { AssetClass, FatTailParams } from './types';
export { FAT_TAIL_PARAMS } from './types';
```

This allows UI components and tests to import fat-tail functionality directly from the simulation module.
  </action>
  <verify>
Run `npm run build` to verify compilation.
Check that imports from '@/simulation' include fat-tail exports.
  </verify>
  <done>
Fat-tail module fully exported from simulation index.
  </done>
</task>

</tasks>

<verification>
1. Run `npm run build` - should complete without errors
2. Run `npm run test` - all tests should pass
3. Run simulation with fat-tail model selected
4. Check console for asset class and parameter logging
5. Compare fat-tail results to regime and bootstrap models
6. Verify terminal value distribution shows fatter tails (more extreme values)
</verification>

<success_criteria>
- 'fat-tail' is valid resamplingMethod option
- generateIterationReturns calls generateCorrelatedFatTailReturns
- Asset class defaults to 'equity_index' if not specified
- Debug stats include fatTailParameters
- Console logging shows fat-tail configuration
- All fat-tail exports available from simulation index
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/23-reference-methodology-alignment/23-07-SUMMARY.md`
</output>
