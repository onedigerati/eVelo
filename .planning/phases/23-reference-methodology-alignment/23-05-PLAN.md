---
phase: 23-reference-methodology-alignment
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - src/calculations/sell-strategy.ts
  - src/simulation/monte-carlo.ts
  - src/simulation/types.ts
autonomous: true

must_haves:
  truths:
    - "Sell strategy uses same return path as BBD iteration"
    - "No synthetic scenario generation for Sell strategy"
    - "BBD and Sell are computed within same Monte Carlo iteration"
  artifacts:
    - path: "src/calculations/sell-strategy.ts"
      provides: "Refactored sell strategy using iteration returns"
      exports: ["calculateSellStrategyFromReturns"]
    - path: "src/simulation/monte-carlo.ts"
      provides: "Integrated sell strategy computation per iteration"
      contains: "sellStrategyResult"
  key_links:
    - from: "src/simulation/monte-carlo.ts"
      to: "src/calculations/sell-strategy.ts"
      via: "calculateSellStrategyFromReturns"
      pattern: "calculateSellStrategyFromReturns.*assetReturns"
---

<objective>
Align sell strategy calculation to use identical market returns as BBD iteration.

Purpose: The current implementation derives growth rates from BBD percentile data and runs 10 synthetic scenarios. The reference application runs ONE sell scenario per BBD iteration using the SAME return sequence. This ensures fair apples-to-apples comparison where the only differences are strategy mechanics (taxes vs borrowing), not different market conditions.

Output: Refactored sell strategy that runs within each Monte Carlo iteration using the same asset returns.
</objective>

<execution_context>
@C:\Users\ungac\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ungac\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/23-reference-methodology-alignment/23-REFERENCE-METHODOLOGY.md
@src/calculations/sell-strategy.ts
@src/simulation/monte-carlo.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add calculateSellStrategyFromReturns function</name>
  <files>src/calculations/sell-strategy.ts</files>
  <action>
Add a new function that accepts raw returns instead of percentile data:

```typescript
/**
 * Configuration for sell strategy calculation with raw returns
 */
export interface SellStrategyFromReturnsConfig {
  /** Initial portfolio value */
  initialValue: number;
  /** Annual withdrawal amount */
  annualWithdrawal: number;
  /** Annual withdrawal growth rate (e.g., 0.03 for 3%) */
  withdrawalGrowth: number;
  /** Time horizon in years */
  timeHorizon: number;
  /** Capital gains tax rate (default: 0.238 for 23.8%) */
  capitalGainsRate?: number;
  /** Initial cost basis as fraction of portfolio (default: 0.4 for 40%) */
  costBasisRatio?: number;
  /** Annual dividend yield (default: 0.02 for 2%) */
  dividendYield?: number;
  /** Dividend tax rate (default: same as capital gains) */
  dividendTaxRate?: number;
  /** Year to start withdrawals (0-indexed, default: 0) */
  withdrawalStartYear?: number;
}

/**
 * Result from single iteration sell strategy
 */
export interface SellIterationResult {
  /** Terminal portfolio value after all years */
  terminalValue: number;
  /** Total capital gains taxes paid */
  totalCapitalGainsTaxes: number;
  /** Total dividend taxes paid */
  totalDividendTaxes: number;
  /** Total taxes (capital gains + dividends) */
  totalTaxes: number;
  /** Whether portfolio was depleted before end */
  depleted: boolean;
  /** Year of depletion (-1 if not depleted) */
  depletionYear: number;
  /** Yearly portfolio values */
  yearlyValues: number[];
  /** Yearly taxes paid */
  yearlyTaxes: number[];
}

/**
 * Calculate sell strategy outcome for a single iteration using actual returns.
 *
 * CRITICAL: This function uses the SAME return sequence as the corresponding
 * BBD iteration, ensuring fair comparison. The only differences in outcomes
 * come from strategy mechanics (taxes vs borrowing), not different markets.
 *
 * Order of operations per year (matches reference):
 * 1. Dividend income generates tax liability, paid from portfolio
 * 2. Withdrawal + capital gains tax reduces portfolio (gross-up for taxes)
 * 3. Market returns applied to reduced portfolio
 *
 * @param config Sell strategy configuration
 * @param portfolioReturns Annual portfolio returns (weighted by asset) for this iteration
 * @returns Single iteration sell strategy result
 */
export function calculateSellStrategyFromReturns(
  config: SellStrategyFromReturnsConfig,
  portfolioReturns: number[]
): SellIterationResult {
  const {
    initialValue,
    annualWithdrawal,
    withdrawalGrowth,
    timeHorizon,
    capitalGainsRate = DEFAULT_SELL_CONFIG.capitalGainsRate,
    costBasisRatio = DEFAULT_SELL_CONFIG.costBasisRatio,
    dividendYield = DEFAULT_SELL_CONFIG.dividendYield,
    dividendTaxRate = DEFAULT_SELL_CONFIG.dividendTaxRate,
    withdrawalStartYear = 0,
  } = config;

  let portfolioValue = initialValue;
  let costBasis = initialValue * costBasisRatio;
  let currentWithdrawal = annualWithdrawal;
  let totalCapitalGainsTaxes = 0;
  let totalDividendTaxes = 0;
  let depleted = false;
  let depletionYear = -1;

  const yearlyValues: number[] = [initialValue];
  const yearlyTaxes: number[] = [0];

  for (let year = 0; year < timeHorizon; year++) {
    if (portfolioValue <= 0) {
      depleted = true;
      if (depletionYear === -1) depletionYear = year;
      yearlyValues.push(0);
      yearlyTaxes.push(0);
      continue;
    }

    let yearTax = 0;

    // 1. DIVIDEND TAX (paid from portfolio, not borrowed like BBD)
    if (dividendYield > 0) {
      const dividendIncome = portfolioValue * dividendYield;
      const dividendTax = dividendIncome * dividendTaxRate;
      totalDividendTaxes += dividendTax;
      yearTax += dividendTax;
      portfolioValue -= dividendTax;

      if (portfolioValue <= 0) {
        depleted = true;
        if (depletionYear === -1) depletionYear = year;
        yearlyValues.push(0);
        yearlyTaxes.push(yearTax);
        continue;
      }
    }

    // 2. WITHDRAWAL + CAPITAL GAINS TAX (only after withdrawal start year)
    if (year >= withdrawalStartYear && currentWithdrawal > 0) {
      const withdrawal = currentWithdrawal;
      currentWithdrawal *= (1 + withdrawalGrowth);

      if (withdrawal >= portfolioValue) {
        // Full depletion
        const basisRatio = costBasis / portfolioValue;
        const gain = portfolioValue - (portfolioValue * basisRatio);
        const tax = gain > 0 ? gain * capitalGainsRate : 0;
        totalCapitalGainsTaxes += tax;
        yearTax += tax;
        portfolioValue = 0;
        depleted = true;
        if (depletionYear === -1) depletionYear = year;
        yearlyValues.push(0);
        yearlyTaxes.push(yearTax);
        continue;
      }

      // Calculate capital gains tax on sale
      const basisPerDollar = portfolioValue > 0 ? costBasis / portfolioValue : 0;
      const saleAmount = withdrawal;
      const basisSold = saleAmount * basisPerDollar;
      const gain = saleAmount - basisSold;
      const capitalGainsTax = gain > 0 ? gain * capitalGainsRate : 0;
      totalCapitalGainsTaxes += capitalGainsTax;
      yearTax += capitalGainsTax;

      // Gross-up: total amount to sell = withdrawal + tax
      const grossSale = saleAmount + capitalGainsTax;

      if (grossSale >= portfolioValue) {
        portfolioValue = 0;
        depleted = true;
        if (depletionYear === -1) depletionYear = year;
        yearlyValues.push(0);
        yearlyTaxes.push(yearTax);
        continue;
      }

      // Update portfolio and basis
      const saleFraction = grossSale / portfolioValue;
      portfolioValue -= grossSale;
      costBasis *= (1 - saleFraction);
    }

    // 3. APPLY MARKET RETURNS (same returns as BBD iteration)
    const portfolioReturn = portfolioReturns[year] ?? 0;
    portfolioValue *= (1 + portfolioReturn);

    // Ensure non-negative
    if (portfolioValue < 0) portfolioValue = 0;

    yearlyValues.push(portfolioValue);
    yearlyTaxes.push(yearTax);
  }

  return {
    terminalValue: portfolioValue,
    totalCapitalGainsTaxes,
    totalDividendTaxes,
    totalTaxes: totalCapitalGainsTaxes + totalDividendTaxes,
    depleted,
    depletionYear,
    yearlyValues,
    yearlyTaxes,
  };
}
```
  </action>
  <verify>
Run `npm run build` to verify compilation.
Check that calculateSellStrategyFromReturns is exported.
  </verify>
  <done>
New function calculateSellStrategyFromReturns processes sell strategy using same returns as BBD.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add SellStrategyOutput type to simulation types</name>
  <files>src/simulation/types.ts</files>
  <action>
Add types to support integrated sell strategy in SimulationOutput:

```typescript
/**
 * Sell strategy output from integrated Monte Carlo simulation
 */
export interface SellStrategyOutput {
  /** Terminal values for all iterations */
  terminalValues: Float64Array;
  /** Success rate (terminal > initial) */
  successRate: number;
  /** Median terminal value */
  median: number;
  /** P10 terminal value */
  p10: number;
  /** P90 terminal value */
  p90: number;
  /** Median lifetime capital gains taxes */
  medianCapitalGainsTaxes: number;
  /** Median lifetime dividend taxes */
  medianDividendTaxes: number;
  /** Median total taxes */
  medianTotalTaxes: number;
  /** Depletion probability (0-100) */
  depletionProbability: number;
  /** Yearly percentiles (from sell strategy paths) */
  yearlyPercentiles: YearlyPercentiles[];
}
```

Add to SimulationOutput:
```typescript
export interface SimulationOutput {
  // ... existing fields ...

  /** Sell strategy results (computed using same returns as BBD) */
  sellStrategy?: SellStrategyOutput;
}
```
  </action>
  <verify>
Run `npm run build` to verify compilation.
  </verify>
  <done>
SellStrategyOutput type defined and added to SimulationOutput.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate sell strategy into Monte Carlo iteration loop</name>
  <files>src/simulation/monte-carlo.ts</files>
  <action>
Update monte-carlo.ts to compute sell strategy within each iteration:

1. Import the new function:
```typescript
import {
  calculateSellStrategyFromReturns,
  type SellIterationResult,
} from '../calculations/sell-strategy';
```

2. Add sell strategy tracking arrays (near other tracking arrays):
```typescript
// Sell strategy tracking (computed using same returns as BBD)
let sellTerminalValues: Float64Array | null = null;
let sellYearlyValues: number[][] | null = null;
let sellTotalTaxes: number[] | null = null;
let sellCapitalGainsTaxes: number[] | null = null;
let sellDividendTaxes: number[] | null = null;
let sellDepleted: boolean[] | null = null;

if (config.sbloc || config.sellStrategy) {
  sellTerminalValues = new Float64Array(iterations);
  sellYearlyValues = Array.from({ length: timeHorizon + 1 }, () => new Array(iterations));
  sellTotalTaxes = new Array(iterations);
  sellCapitalGainsTaxes = new Array(iterations);
  sellDividendTaxes = new Array(iterations);
  sellDepleted = new Array(iterations);
}
```

3. Inside the iteration loop, after BBD simulation, run sell strategy:
```typescript
// CRITICAL: Run sell strategy with SAME returns as BBD
if (sellTerminalValues && config.sbloc) {
  // Calculate weighted portfolio returns for this iteration
  const portfolioReturns: number[] = [];
  for (let year = 0; year < timeHorizon; year++) {
    let portfolioReturn = 0;
    for (let a = 0; a < numAssets; a++) {
      portfolioReturn += weights[a] * assetReturns[a][year];
    }
    portfolioReturns.push(portfolioReturn);
  }

  const sellConfig = {
    initialValue,
    annualWithdrawal: sblocBaseWithdrawal,
    withdrawalGrowth: sblocRaiseRate,
    timeHorizon,
    capitalGainsRate: config.taxModeling?.ltcgTaxRate ?? 0.238,
    costBasisRatio: config.sellStrategy?.costBasisRatio ?? 0.4,
    dividendYield: config.sellStrategy?.dividendYield ?? config.taxModeling?.dividendYield ?? 0.02,
    dividendTaxRate: config.taxModeling?.ordinaryTaxRate ?? 0.238,
    withdrawalStartYear: sblocWithdrawalStartYear,
  };

  const sellResult = calculateSellStrategyFromReturns(sellConfig, portfolioReturns);

  // Store sell strategy results
  sellTerminalValues[i] = sellResult.terminalValue;
  sellTotalTaxes![i] = sellResult.totalTaxes;
  sellCapitalGainsTaxes![i] = sellResult.totalCapitalGainsTaxes;
  sellDividendTaxes![i] = sellResult.totalDividendTaxes;
  sellDepleted![i] = sellResult.depleted;

  // Store yearly values
  for (let year = 0; year <= timeHorizon; year++) {
    sellYearlyValues![year][i] = sellResult.yearlyValues[year] ?? 0;
  }
}
```

4. After iteration loop, compute sell strategy statistics:
```typescript
// Compute sell strategy output
let sellStrategyOutput: SimulationOutput['sellStrategy'];

if (sellTerminalValues && sellTotalTaxes && sellCapitalGainsTaxes &&
    sellDividendTaxes && sellDepleted && sellYearlyValues) {
  const sellTerminalArray = Array.from(sellTerminalValues);
  const successCount = sellTerminalArray.filter(v => v > initialValue).length;
  const depletedCount = sellDepleted.filter(d => d).length;

  // Calculate yearly percentiles for sell strategy
  const sellYearlyPercentiles = sellYearlyValues.map((values, year) => ({
    year,
    p10: percentile(values, 10),
    p25: percentile(values, 25),
    p50: percentile(values, 50),
    p75: percentile(values, 75),
    p90: percentile(values, 90),
  }));

  sellStrategyOutput = {
    terminalValues: sellTerminalValues,
    successRate: (successCount / iterations) * 100,
    median: percentile(sellTerminalArray, 50),
    p10: percentile(sellTerminalArray, 10),
    p90: percentile(sellTerminalArray, 90),
    medianCapitalGainsTaxes: percentile(sellCapitalGainsTaxes, 50),
    medianDividendTaxes: percentile(sellDividendTaxes, 50),
    medianTotalTaxes: percentile(sellTotalTaxes, 50),
    depletionProbability: (depletedCount / iterations) * 100,
    yearlyPercentiles: sellYearlyPercentiles,
  };

  console.log(`[MC] Sell strategy computed: success=${sellStrategyOutput.successRate.toFixed(1)}%, median=$${sellStrategyOutput.median.toFixed(0)}`);
}
```

5. Add to return object:
```typescript
return {
  terminalValues,
  yearlyPercentiles,
  statistics,
  sblocTrajectory,
  marginCallStats,
  estateAnalysis,
  debugStats,
  sellStrategy: sellStrategyOutput, // Add this
};
```
  </action>
  <verify>
Run `npm run build` to verify compilation.
Run simulation and check console for sell strategy output.
Compare BBD and Sell success rates - they should differ only due to strategy mechanics.
  </verify>
  <done>
Monte Carlo computes sell strategy using identical returns as BBD within each iteration.
  </done>
</task>

</tasks>

<verification>
1. Run `npm run build` - should complete without errors
2. Run `npm run test` - all tests should pass
3. Run simulation with SBLOC enabled - check console for sell strategy output
4. Verify sell strategy uses same returns (both strategies affected by same market paths)
5. Compare before/after: synthetic scenarios removed, now 1:1 iteration matching
</verification>

<success_criteria>
- calculateSellStrategyFromReturns accepts raw return arrays
- Sell strategy computed within Monte Carlo iteration loop
- Same portfolioReturns array used for both BBD and Sell
- SellStrategyOutput includes success rate, percentiles, taxes
- Sell strategy yearlyPercentiles derived from iteration data
- Console logging confirms integrated computation
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/23-reference-methodology-alignment/23-05-SUMMARY.md`
</output>
