---
phase: 23-reference-methodology-alignment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/simulation/bootstrap.ts
  - src/simulation/monte-carlo.ts
  - src/simulation/types.ts
autonomous: true

must_haves:
  truths:
    - "Bootstrap model samples the same year index for all assets in each iteration"
    - "Asset correlations are preserved in bootstrap resampling"
    - "Simulation results differ from independent sampling baseline"
  artifacts:
    - path: "src/simulation/bootstrap.ts"
      provides: "correlatedBootstrap function with shared year index"
      exports: ["correlatedBootstrap"]
    - path: "src/simulation/monte-carlo.ts"
      provides: "Updated bootstrap call using correlatedBootstrap"
      contains: "correlatedBootstrap"
  key_links:
    - from: "src/simulation/monte-carlo.ts"
      to: "src/simulation/bootstrap.ts"
      via: "import correlatedBootstrap"
      pattern: "correlatedBootstrap.*sharedYearIndex"
---

<objective>
Implement bootstrap correlation preservation using shared year index sampling.

Purpose: The current bootstrap implementation samples each asset independently, breaking the natural correlation structure that exists in historical data. For example, if stocks crashed in 2008, bonds and commodities also had specific behaviors that year. Independent sampling loses this correlation.

Output: Updated bootstrap module with correlatedBootstrap function that samples the same historical year for all assets, preserving natural cross-asset correlations.
</objective>

<execution_context>
@C:\Users\ungac\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ungac\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/23-reference-methodology-alignment/23-REFERENCE-METHODOLOGY.md
@src/simulation/bootstrap.ts
@src/simulation/monte-carlo.ts
@src/simulation/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add correlatedBootstrap function to bootstrap.ts</name>
  <files>src/simulation/bootstrap.ts</files>
  <action>
Add a new function `correlatedBootstrap` that implements shared year index sampling:

```typescript
/**
 * Correlated bootstrap resampling with shared year index
 *
 * CRITICAL FIX: Samples the SAME historical year index for all assets
 * to preserve their natural correlations. Without this, assets are sampled
 * independently which destroys correlation structure.
 *
 * Example: In 2008, stocks fell 37%, bonds rose 5%, commodities fell 25%.
 * Independent sampling might pair 2008 stocks with 2019 bonds - unrealistic.
 * Shared year index ensures we sample the actual 2008 correlation pattern.
 *
 * @param assetReturns Array of historical returns per asset [asset][year]
 * @param targetLength Number of years to generate
 * @param rng Random number generator (0-1)
 * @returns Array of resampled returns [asset][year] with preserved correlations
 */
export function correlatedBootstrap(
  assetReturns: number[][],
  targetLength: number,
  rng: () => number
): number[][] {
  if (assetReturns.length === 0 || assetReturns[0].length === 0) {
    throw new Error('Cannot bootstrap from empty returns array');
  }

  // Find minimum historical data length across all assets
  const minHistoricalYears = Math.min(...assetReturns.map(r => r.length));

  if (minHistoricalYears === 0) {
    throw new Error('At least one asset has no historical returns');
  }

  const numAssets = assetReturns.length;
  const result: number[][] = Array.from({ length: numAssets }, () => []);

  for (let year = 0; year < targetLength; year++) {
    // CRITICAL: Use shared year index for ALL assets
    // This preserves the natural correlation from that historical year
    const sharedYearIndex = Math.floor(rng() * minHistoricalYears);

    for (let asset = 0; asset < numAssets; asset++) {
      result[asset].push(assetReturns[asset][sharedYearIndex]);
    }
  }

  return result;
}
```

Also add a `correlatedBlockBootstrap` function for block bootstrap with correlation preservation:

```typescript
/**
 * Correlated block bootstrap with shared block selection
 *
 * Combines block bootstrap (preserving autocorrelation) with shared
 * year selection (preserving cross-asset correlation).
 *
 * @param assetReturns Array of historical returns per asset [asset][year]
 * @param targetLength Number of years to generate
 * @param rng Random number generator (0-1)
 * @param blockSize Optional fixed block size (auto-calculated if not provided)
 * @returns Array of resampled returns [asset][year] with preserved correlations
 */
export function correlatedBlockBootstrap(
  assetReturns: number[][],
  targetLength: number,
  rng: () => number,
  blockSize?: number
): number[][] {
  if (assetReturns.length === 0 || assetReturns[0].length === 0) {
    throw new Error('Cannot bootstrap from empty returns array');
  }

  const numAssets = assetReturns.length;
  const minHistoricalYears = Math.min(...assetReturns.map(r => r.length));

  // Calculate effective block size using first asset's returns
  const effectiveBlockSize = blockSize ?? optimalBlockLength(assetReturns[0]);
  const safeBlockSize = Math.min(effectiveBlockSize, minHistoricalYears);

  if (safeBlockSize < 1) {
    throw new Error('Block size must be at least 1');
  }

  const result: number[][] = Array.from({ length: numAssets }, () => []);
  const maxStart = minHistoricalYears - safeBlockSize;

  while (result[0].length < targetLength) {
    // CRITICAL: Use shared block start for ALL assets
    const sharedStartIdx = maxStart > 0 ? Math.floor(rng() * (maxStart + 1)) : 0;

    for (let i = 0; i < safeBlockSize && result[0].length < targetLength; i++) {
      for (let asset = 0; asset < numAssets; asset++) {
        result[asset].push(assetReturns[asset][sharedStartIdx + i]);
      }
    }
  }

  return result;
}
```

Export both new functions from the module.
  </action>
  <verify>
Run `npm run build` to verify TypeScript compilation succeeds.
Check that both `correlatedBootstrap` and `correlatedBlockBootstrap` are exported.
  </verify>
  <done>
Two new functions exist in bootstrap.ts: correlatedBootstrap for simple bootstrap with shared year index, and correlatedBlockBootstrap for block bootstrap with shared block selection.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire correlatedBootstrap into Monte Carlo simulation</name>
  <files>src/simulation/monte-carlo.ts, src/simulation/types.ts</files>
  <action>
Update the `generateIterationReturns` function in monte-carlo.ts to use the new correlated bootstrap functions:

1. Import the new functions:
```typescript
import {
  simpleBootstrap,
  blockBootstrap,
  correlatedBootstrap,
  correlatedBlockBootstrap
} from './bootstrap';
```

2. Modify the bootstrap branch in generateIterationReturns:

```typescript
// Bootstrap methods - CRITICAL FIX: Use shared year index for correlation preservation
// Gather all asset historical returns into a 2D array
const assetReturns = portfolio.assets.map(a => a.historicalReturns);

if (method === 'block') {
  // Correlated block bootstrap - preserves both autocorrelation and cross-asset correlation
  return correlatedBlockBootstrap(assetReturns, years, rng, blockSize);
} else {
  // 'simple' bootstrap with correlation preservation
  return correlatedBootstrap(assetReturns, years, rng);
}
```

3. Add a console log to indicate correlated bootstrap is being used (for debugging):
```typescript
// At start of function for bootstrap methods:
if (method === 'simple' || method === 'block') {
  console.log(`[MC] Using correlated ${method} bootstrap (shared year index)`);
}
```

Remove the old per-asset loop that called simpleBootstrap/blockBootstrap independently.
  </action>
  <verify>
Run `npm run build` to verify TypeScript compilation.
Run `npm run dev` and perform a simulation with "Bootstrap" return model selected.
Check browser console for "[MC] Using correlated simple bootstrap" message.
  </verify>
  <done>
Monte Carlo simulation uses correlatedBootstrap for simple bootstrap and correlatedBlockBootstrap for block bootstrap, ensuring all assets sample the same historical years.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for correlated bootstrap</name>
  <files>src/simulation/__tests__/bootstrap.test.ts</files>
  <action>
Create a new test file for bootstrap functions that verifies correlation preservation:

```typescript
import { describe, it, expect } from 'vitest';
import {
  simpleBootstrap,
  blockBootstrap,
  correlatedBootstrap,
  correlatedBlockBootstrap,
} from '../bootstrap';

describe('correlatedBootstrap', () => {
  // Deterministic RNG for testing
  const createRng = (seed: number) => {
    let s = seed;
    return () => {
      s = (s * 9301 + 49297) % 233280;
      return s / 233280;
    };
  };

  it('samples same year index for all assets', () => {
    // Create assets with distinct patterns to verify shared sampling
    const assetReturns = [
      [0.10, 0.20, 0.30, 0.40],  // Asset 1: increasing
      [0.15, 0.25, 0.35, 0.45],  // Asset 2: offset by 0.05
      [0.20, 0.30, 0.40, 0.50],  // Asset 3: offset by 0.10
    ];

    const rng = createRng(42);
    const result = correlatedBootstrap(assetReturns, 10, rng);

    // Verify all assets have same length
    expect(result.length).toBe(3);
    expect(result[0].length).toBe(10);
    expect(result[1].length).toBe(10);
    expect(result[2].length).toBe(10);

    // Verify correlation is preserved: differences should match original offsets
    for (let year = 0; year < 10; year++) {
      const asset1 = result[0][year];
      const asset2 = result[1][year];
      const asset3 = result[2][year];

      // If shared index, asset2 - asset1 should always be 0.05
      expect(asset2 - asset1).toBeCloseTo(0.05, 10);
      // Asset3 - asset1 should always be 0.10
      expect(asset3 - asset1).toBeCloseTo(0.10, 10);
    }
  });

  it('handles assets with different history lengths', () => {
    // Asset 1 has 5 years, Asset 2 has 3 years
    const assetReturns = [
      [0.10, 0.20, 0.30, 0.40, 0.50],
      [0.11, 0.21, 0.31],
    ];

    const rng = createRng(42);
    const result = correlatedBootstrap(assetReturns, 10, rng);

    // Should use minimum length (3) for all sampling
    expect(result[0].length).toBe(10);
    expect(result[1].length).toBe(10);

    // All sampled values should be from first 3 years only
    for (let year = 0; year < 10; year++) {
      expect([0.10, 0.20, 0.30]).toContain(result[0][year]);
      expect([0.11, 0.21, 0.31]).toContain(result[1][year]);
    }
  });

  it('throws on empty asset returns', () => {
    expect(() => correlatedBootstrap([], 10, () => 0.5)).toThrow();
    expect(() => correlatedBootstrap([[]], 10, () => 0.5)).toThrow();
  });
});

describe('correlatedBlockBootstrap', () => {
  const createRng = (seed: number) => {
    let s = seed;
    return () => {
      s = (s * 9301 + 49297) % 233280;
      return s / 233280;
    };
  };

  it('preserves correlation within blocks', () => {
    const assetReturns = [
      [0.10, 0.20, 0.30, 0.40, 0.50, 0.60],
      [0.15, 0.25, 0.35, 0.45, 0.55, 0.65],
    ];

    const rng = createRng(42);
    const result = correlatedBlockBootstrap(assetReturns, 6, rng, 3);

    // Verify correlation maintained
    for (let year = 0; year < 6; year++) {
      expect(result[1][year] - result[0][year]).toBeCloseTo(0.05, 10);
    }
  });
});
```
  </action>
  <verify>
Run `npm run test` to execute the new tests.
All tests should pass, verifying correlation preservation.
  </verify>
  <done>
Unit tests confirm that correlatedBootstrap samples the same year index for all assets, preserving their natural correlation structure.
  </done>
</task>

</tasks>

<verification>
1. Run `npm run build` - should complete without errors
2. Run `npm run test` - new bootstrap tests should pass
3. Run simulation with Bootstrap model - check console for "correlated" message
4. Compare correlation heatmap before/after - correlations should be preserved
</verification>

<success_criteria>
- correlatedBootstrap and correlatedBlockBootstrap functions exist and are exported
- Monte Carlo simulation uses correlated bootstrap for simple and block methods
- Unit tests verify shared year index sampling behavior
- Build and existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/23-reference-methodology-alignment/23-01-SUMMARY.md`
</output>
