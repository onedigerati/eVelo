---
phase: 23-reference-methodology-alignment
plan: 09
type: execute
wave: 3
depends_on: [23-01, 23-02, 23-04, 23-05, 23-06, 23-07]
files_modified:
  - src/simulation/monte-carlo.ts
  - src/simulation/__tests__/methodology-alignment.test.ts
autonomous: true

must_haves:
  truths:
    - "Path-coherent percentiles use consistent simulation paths"
    - "Terminal net worth sorting determines percentile assignment"
    - "Percentile paths are complete year-by-year journeys"
  artifacts:
    - path: "src/simulation/monte-carlo.ts"
      provides: "Verified path-coherent percentile extraction"
      contains: "pathCoherentPercentiles"
    - path: "src/simulation/__tests__/methodology-alignment.test.ts"
      provides: "Tests verifying reference methodology alignment"
      exports: []
  key_links:
    - from: "src/simulation/monte-carlo.ts"
      to: "src/simulation/types.ts"
      via: "YearlyPercentiles type"
      pattern: "sortBy.*terminalValue.*percentilePaths"
---

<objective>
Verify and document path-coherent percentile extraction methodology.

Purpose: The reference application extracts percentile paths by ranking simulations by TERMINAL value, then extracting the COMPLETE journey of that ranked simulation. This ensures each percentile line represents a coherent path, not a cross-section of different simulations at each year. eVelo appears to use point-wise percentiles which may create misleading paths. This plan audits and documents the approach.

Output: Verified path-coherent percentile methodology with tests confirming reference alignment.
</objective>

<execution_context>
@C:\Users\ungac\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ungac\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/23-reference-methodology-alignment/23-REFERENCE-METHODOLOGY.md
@src/simulation/monte-carlo.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Audit current percentile extraction approach</name>
  <files>src/simulation/monte-carlo.ts</files>
  <action>
Examine the current calculateYearlyPercentiles function and document its approach:

Current implementation (point-wise):
```typescript
function calculateYearlyPercentiles(yearlyValues: number[][]): YearlyPercentiles[] {
  return yearlyValues.map((values, year) => ({
    year: year + 1,
    p10: percentile(values, 10),
    p25: percentile(values, 25),
    p50: percentile(values, 50),
    p75: percentile(values, 75),
    p90: percentile(values, 90),
  }));
}
```

This is POINT-WISE: For each year, it takes the Nth percentile VALUE across all iterations.

The REFERENCE uses PATH-COHERENT: Rank ALL simulations by their TERMINAL value, then for each percentile, extract that specific simulation's complete path.

Add detailed comments explaining the difference:
```typescript
/**
 * Calculate percentiles for each year
 *
 * METHODOLOGY NOTE: There are two approaches to percentile paths:
 *
 * 1. POINT-WISE (current implementation):
 *    - For each year, calculate the Nth percentile VALUE across all iterations
 *    - Each percentile line may combine values from DIFFERENT simulations
 *    - Example: P10 at year 5 might be from sim #42, P10 at year 6 from sim #87
 *    - Pros: Simpler, always shows Nth percentile value for each year
 *    - Cons: Lines may not represent realistic paths (combining different market histories)
 *
 * 2. PATH-COHERENT (reference implementation):
 *    - Rank all simulations by their TERMINAL value (final year)
 *    - P10 line = the complete path of the simulation at the 10th percentile ranking
 *    - Each percentile line represents ONE simulation's journey from start to finish
 *    - Pros: More realistic paths, coherent market history
 *    - Cons: Mid-path values may not be exactly the Nth percentile for that year
 *
 * The current implementation uses POINT-WISE percentiles.
 * See extractPathCoherentPercentiles for PATH-COHERENT alternative.
 */
function calculateYearlyPercentiles(yearlyValues: number[][]): YearlyPercentiles[] {
  // ... existing implementation
}
```
  </action>
  <verify>
Review the comments and confirm understanding of both approaches.
  </verify>
  <done>
Current approach documented as point-wise percentiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement path-coherent percentile extraction</name>
  <files>src/simulation/monte-carlo.ts</files>
  <action>
Add a new function for path-coherent percentile extraction:

```typescript
/**
 * Extract path-coherent percentiles
 *
 * This is the REFERENCE application methodology:
 * 1. Rank all simulations by their TERMINAL (final) net worth
 * 2. Identify which simulation index represents each percentile
 * 3. Extract the COMPLETE path for each percentile simulation
 *
 * Result: Each percentile line represents ONE coherent simulation path,
 * not a cross-section of different simulations at each year.
 *
 * @param yearlyValues 2D array [year][iteration] of portfolio values
 * @param terminalValues Final net worth for each iteration
 * @returns Object with percentile paths and simulation indices
 */
interface PathCoherentResult {
  percentiles: YearlyPercentiles[];
  /** Which simulation index represents each percentile */
  simulationIndices: {
    p10: number;
    p25: number;
    p50: number;
    p75: number;
    p90: number;
  };
}

function extractPathCoherentPercentiles(
  yearlyValues: number[][],
  terminalValues: Float64Array | number[]
): PathCoherentResult {
  const iterations = terminalValues.length;
  const years = yearlyValues.length;

  // Create array of [iteration index, terminal value] pairs
  const rankedSimulations = Array.from(terminalValues)
    .map((value, index) => ({ index, terminalValue: value }))
    // Filter out invalid values (NaN, Infinity)
    .filter(s => isFinite(s.terminalValue))
    // Sort by terminal value (lowest to highest)
    .sort((a, b) => a.terminalValue - b.terminalValue);

  const n = rankedSimulations.length;

  // Find simulation index for each percentile
  const getPercentileIndex = (p: number) => {
    const rank = Math.min(Math.floor((p / 100) * n), n - 1);
    return rankedSimulations[rank].index;
  };

  const simulationIndices = {
    p10: getPercentileIndex(10),
    p25: getPercentileIndex(25),
    p50: getPercentileIndex(50),
    p75: getPercentileIndex(75),
    p90: getPercentileIndex(90),
  };

  // Extract complete paths for each percentile
  const percentiles: YearlyPercentiles[] = [];

  for (let year = 0; year < years; year++) {
    percentiles.push({
      year: year + 1,
      p10: yearlyValues[year][simulationIndices.p10],
      p25: yearlyValues[year][simulationIndices.p25],
      p50: yearlyValues[year][simulationIndices.p50],
      p75: yearlyValues[year][simulationIndices.p75],
      p90: yearlyValues[year][simulationIndices.p90],
    });
  }

  console.log('[MC] Path-coherent percentiles extracted');
  console.log(`[MC]   P10 from simulation #${simulationIndices.p10} (terminal: $${rankedSimulations.find(s => s.index === simulationIndices.p10)?.terminalValue.toFixed(0)})`);
  console.log(`[MC]   P50 from simulation #${simulationIndices.p50} (terminal: $${rankedSimulations.find(s => s.index === simulationIndices.p50)?.terminalValue.toFixed(0)})`);
  console.log(`[MC]   P90 from simulation #${simulationIndices.p90} (terminal: $${rankedSimulations.find(s => s.index === simulationIndices.p90)?.terminalValue.toFixed(0)})`);

  return { percentiles, simulationIndices };
}
```

Update the main runMonteCarlo to use path-coherent percentiles:
```typescript
// After computing terminal values, use path-coherent extraction
const { percentiles: yearlyPercentiles, simulationIndices } =
  extractPathCoherentPercentiles(yearlyValues, terminalValues);
```

Remove or comment out the old calculateYearlyPercentiles call, keeping the function for reference.
  </action>
  <verify>
Run `npm run build` to verify compilation.
Run simulation and check console for "Path-coherent percentiles extracted" message.
Verify percentile simulation indices are logged.
  </verify>
  <done>
Path-coherent percentile extraction implemented matching reference methodology.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create methodology alignment tests</name>
  <files>src/simulation/__tests__/methodology-alignment.test.ts</files>
  <action>
Create a comprehensive test file that validates alignment with reference methodology:

```typescript
import { describe, it, expect } from 'vitest';
import { runMonteCarlo } from '../monte-carlo';
import type { SimulationConfig, PortfolioConfig } from '../types';

describe('Reference Methodology Alignment', () => {
  // Deterministic seed for reproducibility
  const seed = 'test-seed-12345';

  // Simple test portfolio
  const testPortfolio: PortfolioConfig = {
    assets: [
      {
        id: 'TEST-ASSET',
        weight: 1.0,
        historicalReturns: [0.10, 0.15, -0.05, 0.08, -0.20, 0.12, 0.05, -0.10, 0.18, 0.07],
      },
    ],
    correlationMatrix: [[1.0]],
  };

  describe('Bootstrap Correlation Preservation', () => {
    it('uses shared year index for all assets', async () => {
      const multiAssetPortfolio: PortfolioConfig = {
        assets: [
          { id: 'A', weight: 0.5, historicalReturns: [0.10, 0.20, 0.30] },
          { id: 'B', weight: 0.5, historicalReturns: [0.15, 0.25, 0.35] },
        ],
        correlationMatrix: [[1.0, 0.8], [0.8, 1.0]],
      };

      const config: SimulationConfig = {
        iterations: 100,
        timeHorizon: 5,
        initialValue: 1000000,
        inflationAdjusted: false,
        inflationRate: 0,
        resamplingMethod: 'simple',
        seed,
      };

      const result = await runMonteCarlo(config, multiAssetPortfolio);

      // With correlated bootstrap, asset returns should maintain their relationship
      // Since B = A + 0.05 in historical data, they should stay correlated
      expect(result.statistics.mean).toBeGreaterThan(0);
    });
  });

  describe('Survivorship Bias', () => {
    it('applies 1.5% bias in historical mode', async () => {
      const config: SimulationConfig = {
        iterations: 1000,
        timeHorizon: 30,
        initialValue: 1000000,
        inflationAdjusted: false,
        inflationRate: 0,
        resamplingMethod: 'regime',
        regimeCalibration: 'historical',
        seed,
      };

      const result = await runMonteCarlo(config, testPortfolio);

      // Mean should be reduced by survivorship bias
      // Can't test exact value, but check it's reasonable
      expect(result.statistics.mean).toBeDefined();
    });

    it('applies 2.0% bias in conservative mode', async () => {
      const configHistorical: SimulationConfig = {
        iterations: 1000,
        timeHorizon: 30,
        initialValue: 1000000,
        inflationAdjusted: false,
        inflationRate: 0,
        resamplingMethod: 'regime',
        regimeCalibration: 'historical',
        seed,
      };

      const configConservative: SimulationConfig = {
        ...configHistorical,
        regimeCalibration: 'conservative',
      };

      const resultHistorical = await runMonteCarlo(configHistorical, testPortfolio);
      const resultConservative = await runMonteCarlo(configConservative, testPortfolio);

      // Conservative should have lower mean due to higher bias
      expect(resultConservative.statistics.mean).toBeLessThan(resultHistorical.statistics.mean);
    });
  });

  describe('Path-Coherent Percentiles', () => {
    it('extracts complete paths from ranked simulations', async () => {
      const config: SimulationConfig = {
        iterations: 100,
        timeHorizon: 10,
        initialValue: 1000000,
        inflationAdjusted: false,
        inflationRate: 0,
        resamplingMethod: 'simple',
        seed,
      };

      const result = await runMonteCarlo(config, testPortfolio);

      // Check that percentiles form coherent paths (monotonic with terminal)
      // P10 terminal should be less than P50 terminal
      const lastYear = result.yearlyPercentiles[result.yearlyPercentiles.length - 1];
      expect(lastYear.p10).toBeLessThan(lastYear.p50);
      expect(lastYear.p50).toBeLessThan(lastYear.p90);
    });
  });

  describe('4-Regime System', () => {
    it('includes recovery regime in transitions', async () => {
      const config: SimulationConfig = {
        iterations: 1000,
        timeHorizon: 50, // Long horizon to see all regime types
        initialValue: 1000000,
        inflationAdjusted: false,
        inflationRate: 0,
        resamplingMethod: 'regime',
        regimeCalibration: 'historical',
        seed,
      };

      // Just verify it runs without error with 4-regime system
      const result = await runMonteCarlo(config, testPortfolio);
      expect(result.statistics.mean).toBeDefined();
    });
  });
});
```
  </action>
  <verify>
Run `npm run test` to execute the new tests.
All methodology alignment tests should pass.
  </verify>
  <done>
Methodology alignment tests verify bootstrap correlation, survivorship bias, path-coherent percentiles, and 4-regime system.
  </done>
</task>

</tasks>

<verification>
1. Run `npm run build` - should complete without errors
2. Run `npm run test` - methodology alignment tests should pass
3. Run simulation and compare percentile paths to previous behavior
4. Path-coherent paths should show more realistic journeys (no path crossing)
5. Console logging confirms which simulation index represents each percentile
</verification>

<success_criteria>
- extractPathCoherentPercentiles implemented
- Simulations ranked by terminal value to determine percentile assignment
- Complete paths extracted from specific simulations
- Console logging shows percentile simulation indices
- Methodology alignment test file exists with passing tests
- Tests cover: bootstrap correlation, survivorship bias, path-coherent percentiles, 4-regime
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/23-reference-methodology-alignment/23-09-SUMMARY.md`
</output>
