---
phase: 23-reference-methodology-alignment
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/simulation/types.ts
  - src/simulation/regime-switching.ts
autonomous: true

must_haves:
  truths:
    - "Four market regimes exist: bull, bear, crash, recovery"
    - "Transition matrix includes recovery state transitions"
    - "Recovery regime has distinct return distribution parameters"
  artifacts:
    - path: "src/simulation/types.ts"
      provides: "Extended MarketRegime type with recovery state"
      contains: "'bull' | 'bear' | 'crash' | 'recovery'"
    - path: "src/simulation/regime-switching.ts"
      provides: "Updated regime transition functions"
      contains: "recovery"
  key_links:
    - from: "src/simulation/regime-switching.ts"
      to: "src/simulation/types.ts"
      via: "MarketRegime type import"
      pattern: "MarketRegime.*recovery"
---

<objective>
Implement 4-regime system with recovery state and updated transition matrices.

Purpose: The reference application uses a 4-state Markov model (bull/bear/crash/recovery) which more accurately captures market dynamics. After crashes, markets typically enter a recovery phase before returning to bull markets - this affects both return distributions and transition probabilities.

Output: Extended MarketRegime type and transition matrix supporting recovery state with proper transition probabilities.
</objective>

<execution_context>
@C:\Users\ungac\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ungac\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/23-reference-methodology-alignment/23-REFERENCE-METHODOLOGY.md
@src/simulation/types.ts
@src/simulation/regime-switching.ts
@src/simulation/regime-calibration.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend MarketRegime type and add 4-regime constants</name>
  <files>src/simulation/types.ts</files>
  <action>
Update types.ts to support 4-regime system:

1. Extend MarketRegime type:
```typescript
/**
 * Market regime identifier
 * - bull: Strong positive returns, low volatility
 * - bear: Negative returns, elevated volatility
 * - crash: Sharp negative returns, very high volatility
 * - recovery: Post-crash bounce, moderate positive returns with elevated volatility
 */
export type MarketRegime = 'bull' | 'bear' | 'crash' | 'recovery';
```

2. Update TransitionMatrix interface:
```typescript
/**
 * Transition probabilities from one regime to another
 * Each row must sum to 1
 */
export interface TransitionMatrix {
  /** Transition probabilities from bull market */
  bull: { bull: number; bear: number; crash: number; recovery: number };
  /** Transition probabilities from bear market */
  bear: { bull: number; bear: number; crash: number; recovery: number };
  /** Transition probabilities from crash */
  crash: { bull: number; bear: number; crash: number; recovery: number };
  /** Transition probabilities from recovery */
  recovery: { bull: number; bear: number; crash: number; recovery: number };
}
```

3. Update DEFAULT_TRANSITION_MATRIX (historical mode from reference):
```typescript
/**
 * Default transition matrix based on historical market regime analysis
 * Source: Reference PortfolioStrategySimulator.html historical mode
 */
export const DEFAULT_TRANSITION_MATRIX: TransitionMatrix = {
  // From Bull: mostly stays bull, small chance of bear/crash/recovery
  bull: { bull: 0.89, bear: 0.06, crash: 0.02, recovery: 0.03 },
  // From Bear: can go anywhere, often to recovery
  bear: { bull: 0.05, bear: 0.45, crash: 0.20, recovery: 0.30 },
  // From Crash: mostly to recovery, sometimes stays crash
  crash: { bull: 0.00, bear: 0.20, crash: 0.10, recovery: 0.70 },
  // From Recovery: often back to bull, sometimes back to troubles
  recovery: { bull: 0.50, bear: 0.05, crash: 0.02, recovery: 0.43 },
};
```

4. Add conservative mode transition matrix:
```typescript
/**
 * Conservative transition matrix for stress testing
 * Source: Reference PortfolioStrategySimulator.html conservative mode
 * More likely to stay in crash, slower recovery
 */
export const CONSERVATIVE_TRANSITION_MATRIX: TransitionMatrix = {
  bull: { bull: 0.89, bear: 0.06, crash: 0.02, recovery: 0.03 },
  bear: { bull: 0.05, bear: 0.45, crash: 0.20, recovery: 0.30 },
  crash: { bull: 0.00, bear: 0.15, crash: 0.35, recovery: 0.50 },
  recovery: { bull: 0.45, bear: 0.08, crash: 0.02, recovery: 0.45 },
};
```

5. Update DEFAULT_REGIME_PARAMS to include recovery:
```typescript
/**
 * Default regime parameters based on historical market data
 */
export const DEFAULT_REGIME_PARAMS: RegimeParamsMap = {
  bull: { mean: 0.12, stddev: 0.12 },     // 12% return, 12% vol
  bear: { mean: -0.08, stddev: 0.20 },    // -8% return, 20% vol
  crash: { mean: -0.30, stddev: 0.35 },   // -30% return, 35% vol
  recovery: { mean: 0.15, stddev: 0.25 }, // 15% return, 25% vol (post-crash bounce)
};
```

6. Update RegimeParamsMap type:
```typescript
/**
 * Regime parameters for all market states
 */
export type RegimeParamsMap = Record<MarketRegime, RegimeParams>;
```
  </action>
  <verify>
Run `npm run build` to verify TypeScript compilation.
Check that MarketRegime includes 'recovery'.
Verify DEFAULT_TRANSITION_MATRIX rows sum to 1.
  </verify>
  <done>
types.ts defines 4-regime MarketRegime type, updated TransitionMatrix interface, and DEFAULT_TRANSITION_MATRIX with recovery state transitions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update regime-switching.ts for 4-regime system</name>
  <files>src/simulation/regime-switching.ts</files>
  <action>
Update regime-switching.ts to handle 4 regimes:

1. Update nextRegime function:
```typescript
/**
 * Determine next market regime via Markov transition
 *
 * Uses the current regime's row in the transition matrix to
 * probabilistically select the next regime.
 *
 * @param current Current market regime
 * @param matrix Transition probability matrix
 * @param rng Random number generator (0-1)
 * @returns Next market regime
 */
export function nextRegime(
  current: MarketRegime,
  matrix: TransitionMatrix,
  rng: () => number
): MarketRegime {
  const probs = matrix[current];
  const r = rng();

  // Cumulative probability selection for 4 regimes
  let cumulative = 0;

  cumulative += probs.bull;
  if (r < cumulative) return 'bull';

  cumulative += probs.bear;
  if (r < cumulative) return 'bear';

  cumulative += probs.crash;
  if (r < cumulative) return 'crash';

  // Default to recovery (handles floating point edge cases)
  return 'recovery';
}
```

2. Update generateRegimeReturns to handle recovery regime:
No changes needed - the function already uses effectiveParams[currentRegime] which will work with the new recovery key.

3. Update generateCorrelatedRegimeReturns similarly - verify it handles recovery:
The function uses effectiveParams[regime] and assetRegimeParams[asset][regime] which will work with recovery if params are provided.

4. Add validation helper:
```typescript
/**
 * Validate transition matrix sums to 1 for each regime
 */
export function validateTransitionMatrix(matrix: TransitionMatrix): boolean {
  const regimes: MarketRegime[] = ['bull', 'bear', 'crash', 'recovery'];
  const tolerance = 0.001;

  for (const regime of regimes) {
    const probs = matrix[regime];
    const sum = probs.bull + probs.bear + probs.crash + probs.recovery;
    if (Math.abs(sum - 1) > tolerance) {
      console.warn(`Transition matrix row '${regime}' sums to ${sum}, expected 1`);
      return false;
    }
  }
  return true;
}
```
  </action>
  <verify>
Run `npm run build` to verify compilation.
Verify nextRegime returns all 4 regime types correctly.
  </verify>
  <done>
regime-switching.ts supports 4-regime transitions including recovery state, with cumulative probability selection.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update regime-calibration.ts for recovery regime</name>
  <files>src/simulation/regime-calibration.ts</files>
  <action>
Update regime-calibration.ts to handle 4 regimes:

1. Update classifyRegimes function to classify recovery periods:
```typescript
/**
 * Classify historical returns into regimes
 *
 * Uses percentile thresholds to classify each year:
 * - Crash: bottom 10% of returns
 * - Bear: 10-30% percentile
 * - Recovery: Post-crash years with positive returns (special detection)
 * - Bull: top 70% of returns (non-crash, non-bear, non-recovery)
 *
 * Recovery detection: A positive return year immediately following a crash or bear year
 * is classified as recovery if return > 5% (post-crash bounce).
 */
export function classifyRegimes(returns: number[]): MarketRegime[] {
  if (returns.length === 0) return [];

  const sortedReturns = [...returns].sort((a, b) => a - b);
  const n = sortedReturns.length;

  // Percentile thresholds
  const crashThreshold = sortedReturns[Math.floor(n * 0.10)] ?? sortedReturns[0];
  const bearThreshold = sortedReturns[Math.floor(n * 0.30)] ?? sortedReturns[0];

  // First pass: basic classification
  const basicRegimes: MarketRegime[] = returns.map(r => {
    if (r <= crashThreshold) return 'crash';
    if (r <= bearThreshold) return 'bear';
    return 'bull';
  });

  // Second pass: detect recovery years
  // Recovery = positive return year following crash or bear, with return > 5%
  const regimes: MarketRegime[] = basicRegimes.map((regime, i) => {
    if (i === 0) return regime;

    const prevRegime = basicRegimes[i - 1];
    const currentReturn = returns[i];

    // If previous was crash/bear and current is positive with strong return
    if ((prevRegime === 'crash' || prevRegime === 'bear') &&
        currentReturn > 0.05 && regime === 'bull') {
      return 'recovery';
    }

    return regime;
  });

  return regimes;
}
```

2. Update estimateRegimeParams to include recovery:
```typescript
/**
 * Estimate regime parameters from classified returns
 */
export function estimateRegimeParams(
  returns: number[],
  regimes: MarketRegime[]
): RegimeParamsMap {
  const regimeReturns: Record<MarketRegime, number[]> = {
    bull: [],
    bear: [],
    crash: [],
    recovery: [],
  };

  // Group returns by regime
  for (let i = 0; i < returns.length; i++) {
    regimeReturns[regimes[i]].push(returns[i]);
  }

  // Calculate parameters for each regime
  const params: RegimeParamsMap = {
    bull: calculateRegimeParams(regimeReturns.bull, DEFAULT_REGIME_PARAMS.bull),
    bear: calculateRegimeParams(regimeReturns.bear, DEFAULT_REGIME_PARAMS.bear),
    crash: calculateRegimeParams(regimeReturns.crash, DEFAULT_REGIME_PARAMS.crash),
    recovery: calculateRegimeParams(regimeReturns.recovery, DEFAULT_REGIME_PARAMS.recovery),
  };

  return params;
}

function calculateRegimeParams(
  returns: number[],
  fallback: RegimeParams
): RegimeParams {
  if (returns.length < 3) {
    return fallback;
  }

  const regimeMean = mean(returns);
  const regimeStddev = stddev(returns);

  // Validate results
  if (!isFinite(regimeMean) || !isFinite(regimeStddev) || regimeStddev <= 0) {
    return fallback;
  }

  return { mean: regimeMean, stddev: regimeStddev };
}
```

3. Update calibrateRegimeModelWithValidation to validate recovery params.
  </action>
  <verify>
Run `npm run build` to verify compilation.
Run `npm run test` to ensure existing tests pass.
  </verify>
  <done>
regime-calibration.ts classifies returns into 4 regimes including recovery detection, and estimates parameters for all regimes.
  </done>
</task>

</tasks>

<verification>
1. Run `npm run build` - should complete without errors
2. Run `npm run test` - all tests should pass
3. Verify MarketRegime type includes 'recovery'
4. Verify DEFAULT_TRANSITION_MATRIX has recovery transitions
5. Run simulation with Regime-Switching model and check console for regime sequence
</verification>

<success_criteria>
- MarketRegime type includes 'bull', 'bear', 'crash', 'recovery'
- TransitionMatrix interface has recovery row and column
- DEFAULT_TRANSITION_MATRIX matches reference application historical mode
- CONSERVATIVE_TRANSITION_MATRIX exists for stress testing
- nextRegime function handles 4-state transitions
- Regime classification detects recovery periods
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/23-reference-methodology-alignment/23-02-SUMMARY.md`
</output>
