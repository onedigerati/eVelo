---
phase: 23-reference-methodology-alignment
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/simulation/fat-tail.ts
  - src/simulation/types.ts
  - src/simulation/index.ts
autonomous: true

must_haves:
  truths:
    - "Fat-tail model generates returns using Student's t-distribution"
    - "Asset class affects distribution parameters (degrees of freedom, skew)"
    - "Generated returns have fatter tails than normal distribution"
  artifacts:
    - path: "src/simulation/fat-tail.ts"
      provides: "Fat-tail return generation with Student's t"
      exports: ["generateFatTailReturn", "FAT_TAIL_PARAMS"]
    - path: "src/simulation/types.ts"
      provides: "AssetClass type and FatTailParams interface"
      contains: "AssetClass"
  key_links:
    - from: "src/simulation/fat-tail.ts"
      to: "src/simulation/types.ts"
      via: "AssetClass type import"
      pattern: "AssetClass.*equity_stock"
---

<objective>
Implement fat-tail return model with Student's t-distribution and asset-class specific parameters.

Purpose: Normal distributions underestimate the probability of extreme events (crashes). The reference application uses Student's t-distribution with asset-class specific parameters (degrees of freedom, skew multiplier) to generate more realistic tail behavior.

Output: New fat-tail.ts module with Student's t-distribution sampling and asset-class differentiation.
</objective>

<execution_context>
@C:\Users\ungac\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ungac\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/23-reference-methodology-alignment/23-REFERENCE-METHODOLOGY.md
@src/simulation/types.ts
@src/math/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add asset class types and fat-tail parameters to types.ts</name>
  <files>src/simulation/types.ts</files>
  <action>
Add new types for asset classification and fat-tail parameters:

```typescript
// ============================================================================
// Asset Class Types
// ============================================================================

/**
 * Asset class categories for differentiated risk modeling
 *
 * Different asset classes have distinct return characteristics:
 * - equity_stock: Individual stocks (higher volatility, more skew)
 * - equity_index: Broad market indices (moderate volatility)
 * - commodity: Physical commodities (higher volatility, different dynamics)
 * - bond: Fixed income (lower volatility, less fat-tailed)
 */
export type AssetClass = 'equity_stock' | 'equity_index' | 'commodity' | 'bond';

/**
 * Fat-tail distribution parameters by asset class
 */
export interface FatTailParams {
  /** Survivorship bias adjustment (percentage points to subtract from mean) */
  survivorshipBias: number;
  /** Volatility scaling factor (>1 increases volatility) */
  volatilityScaling: number;
  /** Student's t degrees of freedom (lower = fatter tails) */
  degreesOfFreedom: number;
  /** Negative skew multiplier (>1 amplifies negative returns) */
  skewMultiplier: number;
}

/**
 * Fat-tail parameters by asset class
 * Source: Reference PortfolioStrategySimulator.html
 *
 * Lower degrees of freedom = fatter tails (more extreme events)
 * Higher survivorship bias for individual stocks (many fail)
 */
export const FAT_TAIL_PARAMS: Record<AssetClass, FatTailParams> = {
  equity_stock: {
    survivorshipBias: 4.5,      // Individual stocks have high survivorship bias
    volatilityScaling: 1.25,   // 25% higher volatility
    degreesOfFreedom: 4,       // Very fat tails
    skewMultiplier: 1.15,      // 15% more negative skew
  },
  equity_index: {
    survivorshipBias: 2.5,     // Indices are more diversified
    volatilityScaling: 1.15,   // 15% higher volatility
    degreesOfFreedom: 5,       // Fat tails but less extreme
    skewMultiplier: 1.10,      // 10% more negative skew
  },
  commodity: {
    survivorshipBias: 1.0,     // Commodities don't "fail" like stocks
    volatilityScaling: 1.10,   // 10% higher volatility
    degreesOfFreedom: 6,       // Moderately fat tails
    skewMultiplier: 1.05,      // Slight negative skew
  },
  bond: {
    survivorshipBias: 1.5,     // Some default risk
    volatilityScaling: 1.05,   // 5% higher volatility
    degreesOfFreedom: 7,       // Closer to normal
    skewMultiplier: 1.0,       // No additional skew
  },
};
```

Update AssetConfig to include optional assetClass:
```typescript
/**
 * Individual asset configuration
 */
export interface AssetConfig {
  /** Unique asset identifier */
  id: string;
  /** Portfolio weight (0-1, all weights should sum to 1) */
  weight: number;
  /** Historical annual returns for bootstrap resampling */
  historicalReturns: number[];
  /** Asset class for fat-tail modeling (default: equity_index) */
  assetClass?: AssetClass;
  /** Regime-specific parameters (optional, used when resamplingMethod is 'regime') */
  regimeParams?: RegimeParamsMap;
}
```

Add 'fat-tail' to SimulationConfig resamplingMethod:
```typescript
/** Return resampling method */
resamplingMethod: 'simple' | 'block' | 'regime' | 'fat-tail';
```
  </action>
  <verify>
Run `npm run build` to verify TypeScript compilation.
Check that AssetClass and FAT_TAIL_PARAMS are exported.
  </verify>
  <done>
types.ts defines AssetClass type, FatTailParams interface, and FAT_TAIL_PARAMS constants for all four asset classes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create fat-tail.ts module with Student's t-distribution</name>
  <files>src/simulation/fat-tail.ts</files>
  <action>
Create a new file src/simulation/fat-tail.ts:

```typescript
/**
 * Fat-Tail Return Generation
 *
 * Implements Student's t-distribution for generating returns with fatter
 * tails than normal distribution. Based on reference implementation.
 *
 * Key features:
 * - Student's t-distribution with configurable degrees of freedom
 * - Asset-class specific parameters (survivorship bias, volatility scaling)
 * - Negative skew adjustment for realistic crash behavior
 * - Return clamping to prevent extreme unrealistic values
 */

import { normalRandom } from '../math';
import type { AssetClass, FatTailParams } from './types';
import { FAT_TAIL_PARAMS } from './types';

/**
 * Generate Student's t-distributed random variable
 *
 * Uses the standard method: T = Z / sqrt(V/df) where
 * Z is standard normal and V is chi-squared with df degrees of freedom.
 *
 * @param df Degrees of freedom (lower = fatter tails)
 * @param rng Random number generator
 * @returns Student's t random variable
 */
export function studentT(df: number, rng: () => number): number {
  // Generate chi-squared by summing df standard normal squared values
  let chiSquared = 0;
  for (let i = 0; i < df; i++) {
    // Box-Muller for standard normal
    const u1 = Math.max(1e-10, rng()); // Avoid log(0)
    const u2 = rng();
    const z = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
    chiSquared += z * z;
  }

  // Prevent division by very small number (would create extreme values)
  const minChiSquared = df / 400;
  chiSquared = Math.max(minChiSquared, chiSquared);

  // Calculate t scaling factor
  const tScaling = Math.sqrt(df / chiSquared);

  // Generate another standard normal for the t-distribution
  const u1 = Math.max(1e-10, rng());
  const u2 = rng();
  const zNormal = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);

  return zNormal * tScaling;
}

/**
 * Generate a single fat-tailed return for an asset
 *
 * Order of operations:
 * 1. Calculate historical mean and stddev from returns
 * 2. Apply survivorship bias adjustment to mean
 * 3. Apply volatility scaling to stddev
 * 4. Generate Student's t random variable
 * 5. Apply negative skew adjustment
 * 6. Scale and shift to match adjusted distribution
 * 7. Clamp to prevent extreme values
 *
 * @param historicalReturns Array of historical annual returns
 * @param assetClass Asset class for parameter lookup
 * @param rng Random number generator
 * @returns Generated annual return (decimal, e.g., 0.10 for 10%)
 */
export function generateFatTailReturn(
  historicalReturns: number[],
  assetClass: AssetClass,
  rng: () => number
): number {
  if (historicalReturns.length === 0) {
    throw new Error('Cannot generate return from empty historical data');
  }

  // Get asset-class specific parameters
  const params = FAT_TAIL_PARAMS[assetClass];

  // Calculate historical mean and standard deviation
  const n = historicalReturns.length;
  const rawMean = historicalReturns.reduce((sum, r) => sum + r, 0) / n;

  const variance = historicalReturns.reduce(
    (sum, r) => sum + Math.pow(r - rawMean, 2),
    0
  ) / n;
  const rawStdDev = Math.sqrt(variance);

  // Apply survivorship bias adjustment (convert from percentage points)
  // Survivorship bias inflates historical returns; we adjust downward
  const adjustedMean = rawMean - (params.survivorshipBias / 100);

  // Apply volatility scaling
  const adjustedStdDev = rawStdDev * params.volatilityScaling;

  // Generate Student's t random variable
  const t = studentT(params.degreesOfFreedom, rng);

  // Apply negative skew adjustment
  // If t is negative (bad returns), multiply by skewMultiplier to make worse
  const skewAdjustment = t < 0 ? params.skewMultiplier : 1.0;

  // Calculate final return
  const sampledReturn = adjustedMean + (t * adjustedStdDev * skewAdjustment);

  // Clamp at reasonable bounds (-200% to +200%)
  // More extreme clamping than normal model since t-dist already has fat tails
  const clampedReturn = Math.max(-2.0, Math.min(2.0, sampledReturn));

  return clampedReturn;
}

/**
 * Generate correlated fat-tailed returns for multiple assets
 *
 * Uses Cholesky decomposition to introduce correlation between
 * independently generated fat-tail returns.
 *
 * @param assetReturns Historical returns per asset [asset][year]
 * @param assetClasses Asset class for each asset
 * @param correlationMatrix Correlation matrix between assets
 * @param years Number of years to generate
 * @param rng Random number generator
 * @returns Generated returns [asset][year]
 */
export function generateCorrelatedFatTailReturns(
  assetReturns: number[][],
  assetClasses: AssetClass[],
  correlationMatrix: number[][],
  years: number,
  rng: () => number
): number[][] {
  const numAssets = assetReturns.length;

  if (numAssets !== assetClasses.length) {
    throw new Error('Asset returns and classes arrays must have same length');
  }

  // Cholesky decomposition for correlation
  const L = choleskyDecomposition(correlationMatrix);

  const result: number[][] = Array.from({ length: numAssets }, () => []);

  for (let year = 0; year < years; year++) {
    // Generate independent fat-tail returns for each asset
    const independent: number[] = assetClasses.map((assetClass, i) =>
      generateFatTailReturn(assetReturns[i], assetClass, rng)
    );

    // Standardize the returns (subtract mean, divide by stddev)
    const standardized = independent.map((r, i) => {
      const params = FAT_TAIL_PARAMS[assetClasses[i]];
      const n = assetReturns[i].length;
      const mean = assetReturns[i].reduce((s, v) => s + v, 0) / n - params.survivorshipBias / 100;
      const variance = assetReturns[i].reduce((s, v) => s + Math.pow(v - mean, 2), 0) / n;
      const stddev = Math.sqrt(variance) * params.volatilityScaling;
      return stddev > 0 ? (r - mean) / stddev : 0;
    });

    // Apply Cholesky to introduce correlation
    const correlated = L ? applyCholesky(standardized, L) : standardized;

    // Rescale back to original distribution
    for (let i = 0; i < numAssets; i++) {
      const params = FAT_TAIL_PARAMS[assetClasses[i]];
      const n = assetReturns[i].length;
      const mean = assetReturns[i].reduce((s, v) => s + v, 0) / n - params.survivorshipBias / 100;
      const variance = assetReturns[i].reduce((s, v) => s + Math.pow(v - mean, 2), 0) / n;
      const stddev = Math.sqrt(variance) * params.volatilityScaling;

      const rescaled = mean + correlated[i] * stddev;
      result[i].push(Math.max(-2.0, Math.min(2.0, rescaled)));
    }
  }

  return result;
}

/**
 * Simple Cholesky decomposition for correlation matrix
 * Returns lower triangular matrix L such that L * L^T = matrix
 */
function choleskyDecomposition(matrix: number[][]): number[][] | null {
  const n = matrix.length;
  const L: number[][] = Array.from({ length: n }, () => new Array(n).fill(0));

  for (let i = 0; i < n; i++) {
    for (let j = 0; j <= i; j++) {
      let sum = 0;
      for (let k = 0; k < j; k++) {
        sum += L[i][k] * L[j][k];
      }

      if (i === j) {
        const diag = matrix[i][i] - sum;
        if (diag <= 0) {
          // Matrix is not positive definite
          return null;
        }
        L[i][j] = Math.sqrt(diag);
      } else {
        L[i][j] = L[j][j] > 0 ? (matrix[i][j] - sum) / L[j][j] : 0;
      }
    }
  }

  return L;
}

/**
 * Apply Cholesky matrix to transform independent samples into correlated
 */
function applyCholesky(independent: number[], L: number[][]): number[] {
  const n = independent.length;
  const result: number[] = new Array(n).fill(0);

  for (let i = 0; i < n; i++) {
    for (let j = 0; j <= i; j++) {
      result[i] += L[i][j] * independent[j];
    }
  }

  return result;
}
```
  </action>
  <verify>
Run `npm run build` to verify TypeScript compilation.
Check that all functions are properly typed and exported.
  </verify>
  <done>
fat-tail.ts provides Student's t-distribution sampling with asset-class specific parameters and correlation handling.
  </done>
</task>

<task type="auto">
  <name>Task 3: Export fat-tail module and add unit tests</name>
  <files>src/simulation/index.ts, src/simulation/__tests__/fat-tail.test.ts</files>
  <action>
1. Update src/simulation/index.ts to export fat-tail module:
```typescript
// Add to exports
export {
  generateFatTailReturn,
  generateCorrelatedFatTailReturns,
  studentT,
} from './fat-tail';
```

2. Create unit test file src/simulation/__tests__/fat-tail.test.ts:
```typescript
import { describe, it, expect } from 'vitest';
import { studentT, generateFatTailReturn } from '../fat-tail';

describe('studentT', () => {
  const createRng = (seed: number) => {
    let s = seed;
    return () => {
      s = (s * 9301 + 49297) % 233280;
      return s / 233280;
    };
  };

  it('generates values with mean near 0', () => {
    const rng = createRng(42);
    const samples: number[] = [];

    for (let i = 0; i < 1000; i++) {
      samples.push(studentT(5, rng));
    }

    const mean = samples.reduce((s, v) => s + v, 0) / samples.length;
    expect(Math.abs(mean)).toBeLessThan(0.1); // Mean should be near 0
  });

  it('generates fatter tails with lower df', () => {
    const rng1 = createRng(42);
    const rng2 = createRng(42);

    const samplesLowDf: number[] = [];
    const samplesHighDf: number[] = [];

    for (let i = 0; i < 1000; i++) {
      samplesLowDf.push(studentT(3, rng1));
      samplesHighDf.push(studentT(30, rng2));
    }

    // Kurtosis should be higher for lower df (fatter tails)
    const kurtosisLow = calculateKurtosis(samplesLowDf);
    const kurtosisHigh = calculateKurtosis(samplesHighDf);

    // Lower df should have higher kurtosis (fatter tails)
    expect(kurtosisLow).toBeGreaterThan(kurtosisHigh);
  });
});

describe('generateFatTailReturn', () => {
  const createRng = (seed: number) => {
    let s = seed;
    return () => {
      s = (s * 9301 + 49297) % 233280;
      return s / 233280;
    };
  };

  it('generates returns from historical data', () => {
    const historicalReturns = [0.10, 0.15, -0.05, 0.08, -0.20, 0.12];
    const rng = createRng(42);

    const returns: number[] = [];
    for (let i = 0; i < 100; i++) {
      returns.push(generateFatTailReturn(historicalReturns, 'equity_index', rng));
    }

    // Returns should be in reasonable range
    expect(returns.every(r => r >= -2.0 && r <= 2.0)).toBe(true);

    // Mean should be somewhat related to historical mean
    const mean = returns.reduce((s, v) => s + v, 0) / returns.length;
    expect(mean).toBeGreaterThan(-0.5);
    expect(mean).toBeLessThan(0.5);
  });

  it('applies survivorship bias adjustment', () => {
    // equity_stock has 4.5% bias, equity_index has 2.5%
    const historicalReturns = [0.15, 0.15, 0.15, 0.15, 0.15]; // Constant 15%

    const rng1 = createRng(42);
    const rng2 = createRng(42);

    const stockReturns: number[] = [];
    const indexReturns: number[] = [];

    for (let i = 0; i < 500; i++) {
      stockReturns.push(generateFatTailReturn(historicalReturns, 'equity_stock', rng1));
      indexReturns.push(generateFatTailReturn(historicalReturns, 'equity_index', rng2));
    }

    const stockMean = stockReturns.reduce((s, v) => s + v, 0) / stockReturns.length;
    const indexMean = indexReturns.reduce((s, v) => s + v, 0) / indexReturns.length;

    // Stock mean should be lower due to higher survivorship bias adjustment
    expect(stockMean).toBeLessThan(indexMean);
  });

  it('throws on empty historical returns', () => {
    expect(() => generateFatTailReturn([], 'equity_index', () => 0.5)).toThrow();
  });
});

// Helper to calculate kurtosis
function calculateKurtosis(values: number[]): number {
  const n = values.length;
  const mean = values.reduce((s, v) => s + v, 0) / n;
  const m2 = values.reduce((s, v) => s + Math.pow(v - mean, 2), 0) / n;
  const m4 = values.reduce((s, v) => s + Math.pow(v - mean, 4), 0) / n;
  return m4 / (m2 * m2) - 3; // Excess kurtosis
}
```
  </action>
  <verify>
Run `npm run build` to verify compilation.
Run `npm run test` to run the new tests.
All tests should pass.
  </verify>
  <done>
Fat-tail module is exported from simulation index and has unit tests verifying Student's t-distribution behavior and survivorship bias adjustment.
  </done>
</task>

</tasks>

<verification>
1. Run `npm run build` - should complete without errors
2. Run `npm run test` - fat-tail tests should pass
3. Verify FAT_TAIL_PARAMS has all 4 asset classes with different parameters
4. Verify generateFatTailReturn produces fatter-tailed distribution
</verification>

<success_criteria>
- AssetClass type with 4 categories exists
- FAT_TAIL_PARAMS constants match reference application
- generateFatTailReturn uses Student's t-distribution
- Survivorship bias and volatility scaling applied correctly
- Return clamping prevents extreme values
- Unit tests verify fat-tail behavior
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/23-reference-methodology-alignment/23-03-SUMMARY.md`
</output>
