---
phase: 11-complete-results-dashboard
plan: 03
type: execute
wave: 2
depends_on: ["11-01", "11-02"]
files_modified:
  - src/simulation/monte-carlo.ts
  - src/simulation/types.ts
autonomous: true

must_haves:
  truths:
    - "Simulation output includes SBLOC loan balance by year"
    - "Simulation output includes margin call events"
    - "Margin call probability can be computed from simulation results"
  artifacts:
    - path: "src/simulation/types.ts"
      provides: "Extended SimulationOutput with SBLOC data"
      contains: "sblocTrajectory"
    - path: "src/simulation/monte-carlo.ts"
      provides: "SBLOC integration in simulation loop"
      contains: "stepSBLOC"
  key_links:
    - from: "monte-carlo.ts"
      to: "sbloc/engine.ts"
      via: "stepSBLOC function"
      pattern: "import.*stepSBLOC.*from.*sbloc"
---

<objective>
Integrate SBLOC engine into Monte Carlo simulation to produce loan balance trajectory and margin call data.

Purpose: Generate the data needed for SBLOC-related charts (margin call risk, loan balance, BBD comparison).
Output: Simulation output includes yearly SBLOC state, margin call events, and aggregated statistics.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Current simulation
@src/simulation/monte-carlo.ts
@src/simulation/types.ts

# SBLOC engine to integrate
@src/sbloc/engine.ts
@src/sbloc/types.ts
@src/sbloc/index.ts

# Margin call probability calculation
@src/calculations/margin-call-probability.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend simulation types with SBLOC data structures</name>
  <files>src/simulation/types.ts</files>
  <action>
    1. Add SBLOCConfig to SimulationConfig:
       ```typescript
       export interface SimulationConfig {
         // ... existing fields ...
         /** SBLOC configuration (optional - if omitted, no SBLOC simulation) */
         sbloc?: {
           /** Target LTV ratio for borrowing (e.g., 0.5 for 50%) */
           targetLTV: number;
           /** Interest rate (e.g., 0.065 for 6.5%) */
           interestRate: number;
           /** Annual withdrawal amount */
           annualWithdrawal: number;
           /** Maintenance margin (triggers margin call above this) */
           maintenanceMargin: number;
         };
       }
       ```
    2. Add SBLOC output structures:
       ```typescript
       /** Aggregated SBLOC trajectory data (percentiles across iterations) */
       export interface SBLOCTrajectory {
         years: number[];
         loanBalance: {
           p10: number[];
           p25: number[];
           p50: number[];
           p75: number[];
           p90: number[];
         };
         cumulativeWithdrawals: number[];
         cumulativeInterest: {
           p50: number[];
         };
       }

       /** Margin call statistics by year */
       export interface MarginCallStats {
         /** Simulation year (1-based) */
         year: number;
         /** Probability of margin call in this year (0-100) */
         probability: number;
         /** Cumulative probability by this year (0-100) */
         cumulativeProbability: number;
       }

       /** Extended simulation output with SBLOC data */
       export interface SimulationOutput {
         // ... existing fields ...
         /** SBLOC trajectory data (only present if sbloc config provided) */
         sblocTrajectory?: SBLOCTrajectory;
         /** Margin call statistics by year */
         marginCallStats?: MarginCallStats[];
         /** Estate analysis data for BBD comparison */
         estateAnalysis?: {
           /** Median BBD net estate (portfolio - loan) */
           bbdNetEstate: number;
           /** Median sell strategy net estate (portfolio - taxes) */
           sellNetEstate: number;
           /** BBD advantage */
           bbdAdvantage: number;
         };
       }
       ```
  </action>
  <verify>npm run build succeeds</verify>
  <done>Simulation types extended with SBLOC trajectory and margin call structures</done>
</task>

<task type="auto">
  <name>Task 2: Integrate SBLOC stepping into simulation loop</name>
  <files>src/simulation/monte-carlo.ts</files>
  <action>
    1. Import SBLOC functions:
       ```typescript
       import {
         initializeSBLOCState,
         stepSBLOC,
         SBLOCConfig as SBLOCEngineConfig,
         SBLOCState,
       } from '../sbloc';
       ```
    2. Add SBLOC tracking arrays (only if sbloc config provided):
       ```typescript
       // Track SBLOC state per iteration per year
       let sblocStates: SBLOCState[][] | null = null;
       let marginCallYears: number[] | null = null; // First margin call year per iteration (-1 if none)

       if (config.sbloc) {
         sblocStates = Array.from({ length: iterations }, () => []);
         marginCallYears = new Array(iterations).fill(-1);
       }
       ```
    3. Inside the year loop, after portfolio return is applied:
       ```typescript
       if (config.sbloc && sblocStates && marginCallYears) {
         // Get current SBLOC state or initialize
         const prevState = year === 0
           ? initializeSBLOCState(portfolioValue, config.sbloc.annualWithdrawal)
           : sblocStates[i][year - 1];

         // Convert to SBLOC engine config
         const sblocConfig: SBLOCEngineConfig = {
           interestRate: config.sbloc.interestRate,
           compoundingFrequency: 'annual',
           targetLTV: config.sbloc.targetLTV,
           maintenanceMargin: config.sbloc.maintenanceMargin,
           annualWithdrawal: config.sbloc.annualWithdrawal,
         };

         // Step SBLOC forward one year
         const yearResult = stepSBLOC(prevState, portfolioValue, sblocConfig);
         sblocStates[i].push(yearResult.newState);

         // Track first margin call year
         if (yearResult.marginCallTriggered && marginCallYears[i] === -1) {
           marginCallYears[i] = year + 1;
         }

         // Adjust portfolio value for forced liquidation if any
         if (yearResult.portfolioFailed) {
           portfolioValue = 0;
         }
       }
       ```
  </action>
  <verify>npm run build succeeds</verify>
  <done>SBLOC state tracked per iteration per year during simulation</done>
</task>

<task type="auto">
  <name>Task 3: Aggregate SBLOC results after simulation</name>
  <files>src/simulation/monte-carlo.ts</files>
  <action>
    1. After the simulation loop, compute SBLOC aggregates:
       ```typescript
       // Compute SBLOC trajectory and margin call stats
       let sblocTrajectory: SBLOCTrajectory | undefined;
       let marginCallStats: MarginCallStats[] | undefined;
       let estateAnalysis: SimulationOutput['estateAnalysis'] | undefined;

       if (config.sbloc && sblocStates && marginCallYears) {
         // Aggregate loan balances by year
         const loanBalancesByYear = sblocStates[0].map((_, yearIdx) =>
           sblocStates!.map(iterStates => iterStates[yearIdx]?.loanBalance ?? 0)
         );

         sblocTrajectory = {
           years: Array.from({ length: timeHorizon }, (_, i) => i + 1),
           loanBalance: {
             p10: loanBalancesByYear.map(yv => percentile(yv, 0.1)),
             p25: loanBalancesByYear.map(yv => percentile(yv, 0.25)),
             p50: loanBalancesByYear.map(yv => percentile(yv, 0.5)),
             p75: loanBalancesByYear.map(yv => percentile(yv, 0.75)),
             p90: loanBalancesByYear.map(yv => percentile(yv, 0.9)),
           },
           cumulativeWithdrawals: Array.from(
             { length: timeHorizon },
             (_, i) => (i + 1) * config.sbloc!.annualWithdrawal
           ),
           cumulativeInterest: {
             p50: loanBalancesByYear.map((yv, idx) => {
               const cumWithdrawal = (idx + 1) * config.sbloc!.annualWithdrawal;
               const medianLoan = percentile(yv, 0.5);
               return Math.max(0, medianLoan - cumWithdrawal);
             }),
           },
         };

         // Compute margin call statistics
         marginCallStats = computeMarginCallStats(marginCallYears, timeHorizon, iterations);

         // Compute estate analysis (median case)
         const finalStates = sblocStates.map(iterStates => iterStates[timeHorizon - 1]);
         const medianLoan = percentile(finalStates.map(s => s?.loanBalance ?? 0), 0.5);
         const medianPortfolio = statistics.median;
         const bbdNetEstate = medianPortfolio - medianLoan;

         // Estimate taxes if sold (simplified: assume 50% gains, 23.8% tax rate)
         const embeddedGains = Math.max(0, medianPortfolio - initialValue);
         const taxesIfSold = embeddedGains * 0.238;
         const sellNetEstate = medianPortfolio - taxesIfSold;

         estateAnalysis = {
           bbdNetEstate,
           sellNetEstate,
           bbdAdvantage: bbdNetEstate - sellNetEstate,
         };
       }
       ```
    2. Add helper function for margin call stats:
       ```typescript
       function computeMarginCallStats(
         marginCallYears: number[],
         timeHorizon: number,
         iterations: number
       ): MarginCallStats[] {
         const stats: MarginCallStats[] = [];
         let cumulativeCount = 0;

         for (let year = 1; year <= timeHorizon; year++) {
           const callsThisYear = marginCallYears.filter(y => y === year).length;
           const callsByYear = marginCallYears.filter(y => y > 0 && y <= year).length;

           stats.push({
             year,
             probability: (callsThisYear / iterations) * 100,
             cumulativeProbability: (callsByYear / iterations) * 100,
           });
         }

         return stats;
       }
       ```
    3. Include in return:
       ```typescript
       return {
         terminalValues,
         yearlyPercentiles,
         statistics,
         sblocTrajectory,
         marginCallStats,
         estateAnalysis,
       };
       ```
  </action>
  <verify>npm run build succeeds, npm run dev - simulation completes without errors</verify>
  <done>SBLOC trajectory, margin call stats, and estate analysis computed and returned</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm run dev` and run simulation with default SBLOC params
- [ ] console.log(result.sblocTrajectory) shows loan balance percentiles
- [ ] console.log(result.marginCallStats) shows per-year probabilities
- [ ] console.log(result.estateAnalysis) shows BBD vs Sell comparison
- [ ] Simulation without SBLOC config still works (backward compatible)
</verification>

<success_criteria>
- All tasks completed
- SBLOC data structures present in simulation output
- Margin call probabilities computed correctly
- Estate analysis shows reasonable BBD advantage
- No regression in baseline simulation (without SBLOC)
</success_criteria>

<output>
After completion, create `.planning/phases/11-complete-results-dashboard/11-03-SUMMARY.md`
</output>
